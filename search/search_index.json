{
    "docs": [
        {
            "location": "/",
            "text": "Home\n\u00b6\n\n\nRoact is a \ndeclarative\n Lua UI library similar to Facebook's \nReact\n. It exposes a very similar API and implements nearly identical semantics.\n\n\nThis documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect, \nopen an issue on GitHub\n!\n\n\n\n\nInfo\n\n\nThis documentation assumes some familiarity with Lua. If you're new to Lua, \nProgramming in Lua\n by Roberto Ierusalimschy\n is a good introduction, and the first edition (for Lua 5.0) is available online for free.",
            "title": "Home"
        },
        {
            "location": "/#home",
            "text": "Roact is a  declarative  Lua UI library similar to Facebook's  React . It exposes a very similar API and implements nearly identical semantics.  This documentation is based on the structure of React's documentation, but is a work in progress. Many things from React also apply to Roact, but if you find anything missing or incorrect,  open an issue on GitHub !   Info  This documentation assumes some familiarity with Lua. If you're new to Lua,  Programming in Lua  by Roberto Ierusalimschy  is a good introduction, and the first edition (for Lua 5.0) is available online for free.",
            "title": "Home"
        },
        {
            "location": "/guide/installation/",
            "text": "Installation\n\u00b6\n\n\nThere are two supported ways to get started with Roact.\n\n\nFor our examples, we'll install \nRoact\n to \nReplicatedStorage\n. In practice, it's okay to install Roact anywhere you want!\n\n\nMethod 1: Installation Script (Roblox Studio)\n\u00b6\n\n\n\n\nDownload the latest release from the \nGitHub releases page\n.\n\n\nUse the 'Run Script' menu (located in the Test tab) to locate and run this script.\n\n\nFollow the installer's instructions to put Roact into \nReplicatedStorage\n\n\n\n\nMethod 2: Rojo\n\u00b6\n\n\n\n\nInstall \nRojo\n, a file sync plugin\n\n\nPut Roact into your project:\n\n\nCopy the \nlib\n folder into your project, and rename it to \nRoact\n\n\nAlternatively, add a Git submodule to your project\n\n\n\n\n\n\nAdd a partition in Rojo to put Roact into \nReplicatedStorage.Roact",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#installation",
            "text": "There are two supported ways to get started with Roact.  For our examples, we'll install  Roact  to  ReplicatedStorage . In practice, it's okay to install Roact anywhere you want!",
            "title": "Installation"
        },
        {
            "location": "/guide/installation/#method-1-installation-script-roblox-studio",
            "text": "Download the latest release from the  GitHub releases page .  Use the 'Run Script' menu (located in the Test tab) to locate and run this script.  Follow the installer's instructions to put Roact into  ReplicatedStorage",
            "title": "Method 1: Installation Script (Roblox Studio)"
        },
        {
            "location": "/guide/installation/#method-2-rojo",
            "text": "Install  Rojo , a file sync plugin  Put Roact into your project:  Copy the  lib  folder into your project, and rename it to  Roact  Alternatively, add a Git submodule to your project    Add a partition in Rojo to put Roact into  ReplicatedStorage.Roact",
            "title": "Method 2: Rojo"
        },
        {
            "location": "/guide/hello-roact/",
            "text": "Hello, Roact!\n\u00b6\n\n\n\n\nInfo\n\n\nThese examples asssumes that you've successfully \ninstalled Roact\n into \nReplicatedStorage\n!\n\n\n\n\nAdd a new \nLocalScript\n object to \nStarterPlayer.StarterPlayerScripts\n either in Roblox Studio, or via Rojo:\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \napp\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n    \nHelloWorld\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n        \nText\n \n=\n \n\"Hello, Roact!\"\n\n    \n})\n\n\n})\n\n\n\nRoact\n.\nreify\n(\napp\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n)\n\n\n\n\n\n\nWhen you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!",
            "title": "Hello, Roact!"
        },
        {
            "location": "/guide/hello-roact/#hello-roact",
            "text": "Info  These examples asssumes that you've successfully  installed Roact  into  ReplicatedStorage !   Add a new  LocalScript  object to  StarterPlayer.StarterPlayerScripts  either in Roblox Studio, or via Rojo:  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   app   =   Roact . createElement ( \"ScreenGui\" ,   {},   { \n     HelloWorld   =   Roact . createElement ( \"TextLabel\" ,   { \n         Size   =   UDim2 . new ( 0 ,   400 ,   0 ,   300 ), \n         Text   =   \"Hello, Roact!\" \n     })  })  Roact . reify ( app ,   Players . LocalPlayer . PlayerGui )   When you run your game, you should see a large gray label with the phrase 'Hello, Roact!' appear on screen!",
            "title": "Hello, Roact!"
        },
        {
            "location": "/guide/elements/",
            "text": "Elements\n\u00b6\n\n\nLike React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI.\n\n\nElements describe what you want your UI to look like at a single point in time. They're \nimmutable\n: you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal.\n\n\nYou can create an element using \nRoact.createElement\n -- just pass a Roblox class name as the first argument, and any properties as the second argument!\n\n\nlocal\n \nmyElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n50\n,\n \n0\n,\n \n50\n)\n\n\n})\n\n\n\n\n\n\nYou can also represent children by passing them to the optional third argument of \ncreateElement\n:\n\n\nlocal\n \nmyElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n50\n,\n \n0\n,\n \n50\n)\n\n\n},\n \n{\n\n    \nSomeChild\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, Roact!\"\n\n    \n})\n\n\n})\n\n\n\n\n\n\nCreating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call \nRoact.reify\n:\n\n\n-- Create a new Frame object in 'Workspace'\n\n\nlocal\n \nmyHandle\n \n=\n \nRoact\n.\nreify\n(\nmyElement\n,\n \ngame\n.\nWorkspace\n)\n\n\n\n\n\n\nRoact.reify\n returns a handle that we can later use to update or destroy that object with \nRoact.reconcile\n and \nRoact.teardown\n.\n\n\nChanging What's Rendered\n\u00b6\n\n\nIn order to change the UI that we've created, we need to create a new set of elements and \nreconcile\n the existing tree to match it.\n\n\nReconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time.\n\n\nUsing \nmyHandle\n from above, we can update the size and text of our label:\n\n\n-- Make some new elements that describe what our new UI will look like.\n\n\nlocal\n \nmyNewElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n100\n,\n \n0\n,\n \n50\n)\n\n\n},\n \n{\n\n    \nSomeChild\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, again, Roact!\"\n\n    \n})\n\n\n})\n\n\n\n-- Update our hierarchy to match those elements.\n\n\nmyHandle\n \n=\n \nRoact\n.\nreconcile\n(\nmyHandle\n,\n \nmyNewElement\n)\n\n\n\n\n\n\n\n\nInfo\n\n\nMost projects using UI don't use \nRoact.reconcile\n and instead change UI using state and lifecycle events, which will be introduced in the next section.\n\n\nRoact.reconcile\n is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact!\n\n\n\n\nUnlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.\n\n\nDestroying the Tree\n\u00b6\n\n\nRoact provides a method called \nRoact.teardown\n that we can use when we're finished with our tree.\n\n\nRoact\n.\nteardown\n(\nmyHandle\n)\n\n\n\n\n\n\n\n\nWarning\n\n\nOnce \nteardown\n is called, all Roblox Instances get destroyed!\n\n\nTrying to use a handle after it's been passed to \nRoact.teardown\n will result in errors!\n\n\n\n\nIncrementing Counter\n\u00b6\n\n\nUsing what's been covered so far, we can make a simple program that tells you how long it has been running.\n\n\nThis is a complete example that should work when put into a \nLocalScript\n in \nStarterPlayerScripts\n. It assumes Roact has been installed into \nReplicatedStorage\n.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Create a function that creates the elements for our UI.\n\n\n-- Later, we'll use components, which are the best way to organize UI in Roact.\n\n\nlocal\n \nfunction\n \nclock\n(\ncurrentTime\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our initial UI.\n\n\nlocal\n \ncurrentTime\n \n=\n \n0\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nclock\n(\ncurrentTime\n),\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n-- Every second, update the UI to show our new time.\n\n\nwhile\n \ntrue\n \ndo\n\n    \nwait\n(\n1\n)\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n \n+\n \n1\n\n    \nhandle\n \n=\n \nRoact\n.\nreconcile\n(\nhandle\n,\n \nclock\n(\ncurrentTime\n))\n\n\nend\n\n\n\n\n\n\nIn the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.",
            "title": "Elements"
        },
        {
            "location": "/guide/elements/#elements",
            "text": "Like React, everything in Roact is built out of elements. Elements are the smallest building blocks for creating UI.  Elements describe what you want your UI to look like at a single point in time. They're  immutable : you can't change elements once they're created, but you can create new ones. Because creating elements is fast, this is no big deal.  You can create an element using  Roact.createElement  -- just pass a Roblox class name as the first argument, and any properties as the second argument!  local   myElement   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 0 ,   50 ,   0 ,   50 )  })   You can also represent children by passing them to the optional third argument of  createElement :  local   myElement   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 0 ,   50 ,   0 ,   50 )  },   { \n     SomeChild   =   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, Roact!\" \n     })  })   Creating an element by itself doesn't do anything, however. In order to turn our description of an object into a real Roblox Instance, we can call  Roact.reify :  -- Create a new Frame object in 'Workspace'  local   myHandle   =   Roact . reify ( myElement ,   game . Workspace )   Roact.reify  returns a handle that we can later use to update or destroy that object with  Roact.reconcile  and  Roact.teardown .",
            "title": "Elements"
        },
        {
            "location": "/guide/elements/#changing-whats-rendered",
            "text": "In order to change the UI that we've created, we need to create a new set of elements and  reconcile  the existing tree to match it.  Reconciliation is the term that Roact uses to describe the process of updating an existing UI to match what the program wants it to look like at any given time.  Using  myHandle  from above, we can update the size and text of our label:  -- Make some new elements that describe what our new UI will look like.  local   myNewElement   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 0 ,   100 ,   0 ,   50 )  },   { \n     SomeChild   =   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, again, Roact!\" \n     })  })  -- Update our hierarchy to match those elements.  myHandle   =   Roact . reconcile ( myHandle ,   myNewElement )    Info  Most projects using UI don't use  Roact.reconcile  and instead change UI using state and lifecycle events, which will be introduced in the next section.  Roact.reconcile  is mostly useful to embed Roact components into existing, non-Roact projects, and for introducing Roact!   Unlike many other UI systems, Roact doesn't let you directly set values on UI objects. Instead, describe what your UI should look like in the form of elements and Roact will handle changing the underlying Roblox Instances.",
            "title": "Changing What's Rendered"
        },
        {
            "location": "/guide/elements/#destroying-the-tree",
            "text": "Roact provides a method called  Roact.teardown  that we can use when we're finished with our tree.  Roact . teardown ( myHandle )    Warning  Once  teardown  is called, all Roblox Instances get destroyed!  Trying to use a handle after it's been passed to  Roact.teardown  will result in errors!",
            "title": "Destroying the Tree"
        },
        {
            "location": "/guide/elements/#incrementing-counter",
            "text": "Using what's been covered so far, we can make a simple program that tells you how long it has been running.  This is a complete example that should work when put into a  LocalScript  in  StarterPlayerScripts . It assumes Roact has been installed into  ReplicatedStorage .  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Create a function that creates the elements for our UI.  -- Later, we'll use components, which are the best way to organize UI in Roact.  local   function   clock ( currentTime ) \n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our initial UI.  local   currentTime   =   0  local   handle   =   Roact . reify ( clock ( currentTime ),   PlayerGui ,   \"Clock UI\" )  -- Every second, update the UI to show our new time.  while   true   do \n     wait ( 1 ) \n\n     currentTime   =   currentTime   +   1 \n     handle   =   Roact . reconcile ( handle ,   clock ( currentTime ))  end   In the next section, we'll talk about components, which let us create reusable chunks of UI, and introduce the primary technique to change UI in Roact.",
            "title": "Incrementing Counter"
        },
        {
            "location": "/guide/components/",
            "text": "Components\n\u00b6\n\n\nComponents are encapsulated, reusable pieces of UI that you can combine to build a complete UI.\n\n\nComponents accept inputs, known as \nprops\n, and return elements to describe the UI that should represent those inputs.\n\n\nFunctional and Stateful Components\n\u00b6\n\n\nComponents come in two flavors in Roact, \nfunctional\n and \nstateful\n.\n\n\nFunctional components are the simplest: they're just functions that accept props as their only argument, and return some elements.\n\n\nlocal\n \nfunction\n \nGreeting\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\n\n\n\nRoact also has \nstateful\n components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section.\n\n\nYou can create a stateful component by calling \nRoact.Component:extend\n and passing in the component's name.\n\n\nlocal\n \nGreeting\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Greeting\"\n)\n\n\n\nfunction\n \nGreeting\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nself\n.\nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\n\n\n\nUsing Components\n\u00b6\n\n\nIn our previous examples, we passed strings to \nRoact.createElement\n to create elements that represented Roblox Instances.\n\n\nWe can also pass our custom components to create elements that represent them:\n\n\nlocal\n \nhello\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n    \nname\n \n=\n \n\"Rick James\"\n\n\n})\n\n\n\n\n\n\nThe \nname\n value is passed to our component as props, which we can reference as the \nprops\n argument in our functional component or \nself.props\n in our stateful component.\n\n\nComponents in Components\n\u00b6\n\n\nComponents are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components!\n\n\nlocal\n \nfunction\n \nGreeting\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n\"Hello, \"\n \n..\n \nprops\n.\nname\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nfunction\n \nGreetEveryone\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{\n\n        \nLayout\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n),\n\n\n        \nHelloJoe\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n            \nname\n \n=\n \n\"Joe\"\n\n        \n}),\n\n\n        \nHelloMary\n \n=\n \nRoact\n.\ncreateElement\n(\nGreeting\n,\n \n{\n\n            \nname\n \n=\n \n\"Mary\"\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n\n\n\nApplications built using Roact usually have one component at the top of the tree, and include all other pieces as children.\n\n\nIncrementing Counter, Part Two\n\u00b6\n\n\nWe can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Create a functional component that represents our UI\n\n\nlocal\n \nfunction\n \nClock\n(\nprops\n)\n\n\n    \nlocal\n \ncurrentTime\n \n=\n \nprops\n.\ncurrentTime\n\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our initial UI.\n\n\nlocal\n \ncurrentTime\n \n=\n \n0\n\n\n\nlocal\n \nclockElement\n \n=\n \nRoact\n.\ncreateElement\n(\nClock\n,\n \n{\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n\n\n})\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nclockElement\n,\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n\n-- Every second, update the UI to show our new time.\n\n\nwhile\n \ntrue\n \ndo\n\n    \nwait\n(\n1\n)\n\n\n    \ncurrentTime\n \n=\n \ncurrentTime\n \n+\n \n1\n\n\n    \nhandle\n \n=\n \nRoact\n.\nreconcile\n(\nhandle\n,\n \nRoact\n.\ncreateElement\n(\nClock\n,\n \n{\n\n\n        \ncurrentTime\n \n=\n \ncurrentTime\n\n\n    \n}))\n\n\nend",
            "title": "Components"
        },
        {
            "location": "/guide/components/#components",
            "text": "Components are encapsulated, reusable pieces of UI that you can combine to build a complete UI.  Components accept inputs, known as  props , and return elements to describe the UI that should represent those inputs.",
            "title": "Components"
        },
        {
            "location": "/guide/components/#functional-and-stateful-components",
            "text": "Components come in two flavors in Roact,  functional  and  stateful .  Functional components are the simplest: they're just functions that accept props as their only argument, and return some elements.  local   function   Greeting ( props ) \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   props . name \n     })  end   Roact also has  stateful  components, which have additional features, like lifecycle methods and state, that we'll talk about in a later section.  You can create a stateful component by calling  Roact.Component:extend  and passing in the component's name.  local   Greeting   =   Roact . Component : extend ( \"Greeting\" )  function   Greeting : render () \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   self . props . name \n     })  end",
            "title": "Functional and Stateful Components"
        },
        {
            "location": "/guide/components/#using-components",
            "text": "In our previous examples, we passed strings to  Roact.createElement  to create elements that represented Roblox Instances.  We can also pass our custom components to create elements that represent them:  local   hello   =   Roact . createElement ( Greeting ,   { \n     name   =   \"Rick James\"  })   The  name  value is passed to our component as props, which we can reference as the  props  argument in our functional component or  self.props  in our stateful component.",
            "title": "Using Components"
        },
        {
            "location": "/guide/components/#components-in-components",
            "text": "Components are designed to make it easy to re-use pieces of UI, so naturally, we can use components inside other components!  local   function   Greeting ( props ) \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   \"Hello, \"   ..   props . name \n     })  end  local   function   GreetEveryone () \n     return   Roact . createElement ( \"ScreenGui\" ,   { \n         Layout   =   Roact . createElement ( \"UIListLayout\" ), \n\n         HelloJoe   =   Roact . createElement ( Greeting ,   { \n             name   =   \"Joe\" \n         }), \n\n         HelloMary   =   Roact . createElement ( Greeting ,   { \n             name   =   \"Mary\" \n         }) \n     })  end   Applications built using Roact usually have one component at the top of the tree, and include all other pieces as children.",
            "title": "Components in Components"
        },
        {
            "location": "/guide/components/#incrementing-counter-part-two",
            "text": "We can revisit the incrementing counter example from the previous section, now using a functional component. Changed sections are highlighted.  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Create a functional component that represents our UI  local   function   Clock ( props )       local   currentTime   =   props . currentTime  \n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our initial UI.  local   currentTime   =   0  local   clockElement   =   Roact . createElement ( Clock ,   {       currentTime   =   currentTime  })  local   handle   =   Roact . reify ( clockElement ,   PlayerGui ,   \"Clock UI\" )   -- Every second, update the UI to show our new time.  while   true   do \n     wait ( 1 ) \n\n     currentTime   =   currentTime   +   1       handle   =   Roact . reconcile ( handle ,   Roact . createElement ( Clock ,   {           currentTime   =   currentTime       }))  end",
            "title": "Incrementing Counter, Part Two"
        },
        {
            "location": "/guide/state-and-lifecycle/",
            "text": "State and Lifecycle\n\u00b6\n\n\nIn the previous section, we talked about using components to create reusable chunks of state, and introduced \nfunctional\n and \nstateful\n components.\n\n\nStateful components do everything that functional components do, but have the addition of mutable \nstate\n and \nlifecycle methods\n.\n\n\nState\n\u00b6\n\n\n\n\nInfo\n\n\nThis section is incomplete!\n\n\n\n\nLifecycle Methods\n\u00b6\n\n\nStateful components can provide methods to Roact that are called when certain things happen to a component instance.\n\n\nLifecycle methods are a great place to send off network requests, measure UI (\nwith the help of refs\n), wrap non-Roact components, and other side-effects.\n\n\nA \ndiagram of Roact's lifecycle methods\n is available in the API reference.\n\n\nIncrementing Counter, Part Three\n\u00b6\n\n\nBuilding on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use \nsetState\n to trigger a re-render instead of \nRoact.reconcile\n.\n\n\nGenerally, this ticking clock demonstrates how many stateful components are structured in Roact.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \nClock\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"Clock\"\n)\n\n\n\n-- This render function is almost completely unchanged from the first example.\n\n\nfunction\n \nClock\n:\nrender\n()\n\n    \nlocal\n \ncurrentTime\n \n=\n \nself\n.\nprops\n.\ncurrentTime\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n        \nTimeLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Time Elapsed: \"\n \n..\n \ncurrentTime\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- Set up our loop in didMount, so that it starts running when our\n\n\n-- component is created.\n\n\nfunction\n \nClock\n:\ndidMount\n()\n\n    \n-- Set a value that we can change later to stop our loop\n\n    \nself\n.\nrunning\n \n=\n \ntrue\n\n\n    \n-- We don't want to block the main thread, so we spawn a new one!\n\n    \nspawn\n(\nfunction\n()\n\n        \nwhile\n \nself\n.\nrunning\n \ndo\n\n            \n-- Because we depend on the previous state, we use the function\n\n            \n-- variant of setState. This will matter more when Roact gets\n\n            \n-- asynchronous rendering!\n\n            \nself\n:\nsetState\n(\nfunction\n(\nstate\n)\n\n                \nreturn\n \n{\n\n                    \ncurrentTime\n \n=\n \nstate\n.\ncurrentTime\n \n+\n \n1\n\n                \n}\n\n            \nend\n)\n\n\n            \nwait\n(\n1\n)\n\n        \nend\n\n    \nend\n)\n\n\nend\n\n\n\n-- Stop the loop in willUnmount, so that our loop terminates when the\n\n\n-- component is destroyed.\n\n\nfunction\n \nClock\n:\nwillUnmount\n()\n\n    \nself\n.\nrunning\n \n=\n \nfalse\n\n\nend\n\n\n\nlocal\n \nPlayerGui\n \n=\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Create our UI, which now runs on its own!\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nRoact\n.\ncreateElement\n(\nClock\n),\n \nPlayerGui\n,\n \n\"Clock UI\"\n)\n\n\n\n-- Later, we can destroy our UI and disconnect everything correctly.\n\n\nwait\n(\n10\n)\n\n\nRoact\n.\nteardown\n(\nhandle\n)",
            "title": "State and Lifecycle"
        },
        {
            "location": "/guide/state-and-lifecycle/#state-and-lifecycle",
            "text": "In the previous section, we talked about using components to create reusable chunks of state, and introduced  functional  and  stateful  components.  Stateful components do everything that functional components do, but have the addition of mutable  state  and  lifecycle methods .",
            "title": "State and Lifecycle"
        },
        {
            "location": "/guide/state-and-lifecycle/#state",
            "text": "Info  This section is incomplete!",
            "title": "State"
        },
        {
            "location": "/guide/state-and-lifecycle/#lifecycle-methods",
            "text": "Stateful components can provide methods to Roact that are called when certain things happen to a component instance.  Lifecycle methods are a great place to send off network requests, measure UI ( with the help of refs ), wrap non-Roact components, and other side-effects.  A  diagram of Roact's lifecycle methods  is available in the API reference.",
            "title": "Lifecycle Methods"
        },
        {
            "location": "/guide/state-and-lifecycle/#incrementing-counter-part-three",
            "text": "Building on the previous two examples, we can expand the incrementing counter to move the counter state and loop inside Roact, and use  setState  to trigger a re-render instead of  Roact.reconcile .  Generally, this ticking clock demonstrates how many stateful components are structured in Roact.  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Players   =   game : GetService ( \"Players\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   Clock   =   Roact . Component : extend ( \"Clock\" )  -- This render function is almost completely unchanged from the first example.  function   Clock : render () \n     local   currentTime   =   self . props . currentTime \n\n     return   Roact . createElement ( \"ScreenGui\" ,   {},   { \n         TimeLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Time Elapsed: \"   ..   currentTime \n         }) \n     })  end  -- Set up our loop in didMount, so that it starts running when our  -- component is created.  function   Clock : didMount () \n     -- Set a value that we can change later to stop our loop \n     self . running   =   true \n\n     -- We don't want to block the main thread, so we spawn a new one! \n     spawn ( function () \n         while   self . running   do \n             -- Because we depend on the previous state, we use the function \n             -- variant of setState. This will matter more when Roact gets \n             -- asynchronous rendering! \n             self : setState ( function ( state ) \n                 return   { \n                     currentTime   =   state . currentTime   +   1 \n                 } \n             end ) \n\n             wait ( 1 ) \n         end \n     end )  end  -- Stop the loop in willUnmount, so that our loop terminates when the  -- component is destroyed.  function   Clock : willUnmount () \n     self . running   =   false  end  local   PlayerGui   =   Players . LocalPlayer . PlayerGui  -- Create our UI, which now runs on its own!  local   handle   =   Roact . reify ( Roact . createElement ( Clock ),   PlayerGui ,   \"Clock UI\" )  -- Later, we can destroy our UI and disconnect everything correctly.  wait ( 10 )  Roact . teardown ( handle )",
            "title": "Incrementing Counter, Part Three"
        },
        {
            "location": "/guide/events/",
            "text": "Events\n\u00b6\n\n\nRoact manages Instance event connections automatically as part of rendering.\n\n\nTo connect to an event, pass a prop with \nRoact.Event.EVENT_NAME\n as the key and a function as the value.\n\n\nRoact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in.\n\n\nlocal\n \nbutton\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n    \nText\n \n=\n \n\"Click me!\"\n,\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n\n    \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"The button was clicked!\"\n)\n\n    \nend\n\n\n})\n\n\n\n\n\n\n\n\nInfo\n\n\nEvents will automatically be disconnected when a component instance is unmounted!",
            "title": "Events"
        },
        {
            "location": "/guide/events/#events",
            "text": "Roact manages Instance event connections automatically as part of rendering.  To connect to an event, pass a prop with  Roact.Event.EVENT_NAME  as the key and a function as the value.  Roact will pass the instance that the event is connected to as the first argument to the event callback, followed by any arguments that Roblox passed in.  local   button   =   Roact . createElement ( \"TextButton\" ,   { \n     Text   =   \"Click me!\" , \n     Size   =   UDim2 . new ( 0 ,   400 ,   0 ,   300 ), \n\n     [ Roact . Event . MouseButton1Click ]   =   function ( rbx ) \n         print ( \"The button was clicked!\" ) \n     end  })    Info  Events will automatically be disconnected when a component instance is unmounted!",
            "title": "Events"
        },
        {
            "location": "/advanced/portals/",
            "text": "Portals\n\u00b6\n\n\nPortals\n are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance.\n\n\n\n\nInfo\n\n\nEventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game, \nPortal\n.\n\n\n\n\nTo create a portal, use the \nRoact.Portal\n component with \ncreateElement\n:\n\n\nlocal\n \nfunction\n \nPartInWorkspace\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\nRoact\n.\nPortal\n,\n \n{\n\n        \ntarget\n \n=\n \nWorkspace\n\n    \n},\n \n{\n\n        \nSomePart\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Part\"\n,\n \n{\n\n            \nAnchored\n \n=\n \ntrue\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n\n\n\nWhen we create \nPartInWorkspace\n, even if it's deep into our Roact tree, a \nPart\n Instance named \nSomePart\n will be created in \nWorkspace\n.\n\n\n\n\nWarning\n\n\nPortals should only be created to objects that aren't managed by Roact!\n\n\n\n\nOne particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them!\n\n\nlocal\n \nPlayerGui\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n).\nLocalPlayer\n.\nPlayerGui\n\n\n\n-- Our Modal component is a standard component, but with a portal at the top!\n\n\nlocal\n \nfunction\n \nModal\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\nRoact\n.\nPortal\n,\n \n{\n\n        \ntarget\n \n=\n \nPlayerGui\n\n    \n},\n \n{\n\n        \nModal\n \n=\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{},\n \n{\n\n            \nLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n                \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n                \nText\n \n=\n \n\"Click me to close!\"\n,\n\n\n                \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nfunction\n()\n\n                    \nprops\n.\nonClose\n()\n\n                \nend\n\n            \n})\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- A ModalButton contains a little bit of state to decide whether the dialog\n\n\n-- should be open or not.\n\n\nlocal\n \nModalButton\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"ModalButton\"\n)\n\n\n\nfunction\n \nModalButton\n:\ninit\n()\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \ndialogOpen\n \n=\n \nfalse\n\n    \n}\n\n\nend\n\n\n\nfunction\n \nModalButton\n:\nrender\n()\n\n    \nlocal\n \ndialog\n \n=\n \nnil\n\n\n    \n-- If the dialog isn't open, just avoid rendering it.\n\n    \nif\n \nself\n.\nstate\n.\ndialogOpen\n \nthen\n\n        \ndialog\n \n=\n \nRoact\n.\ncreateElement\n(\nModal\n,\n \n{\n\n            \nonClose\n \n=\n \nfunction\n()\n\n                \nself\n:\nsetState\n({\n\n                    \ndialogOpen\n \n=\n \nfalse\n\n                \n})\n\n            \nend\n\n        \n})\n\n    \nend\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0\n,\n \n400\n,\n \n0\n,\n \n300\n),\n\n        \nText\n \n=\n \n\"Click me to open modal dialog!\"\n,\n\n\n        \n[\nRoact\n.\nEvent\n.\nActivated\n]\n \n=\n \nfunction\n()\n\n            \nself\n:\nsetState\n({\n\n                \ndialogOpen\n \n=\n \ntrue\n\n            \n})\n\n        \nend\n\n    \n},\n \n{\n\n        \n-- If `dialog` ends up nil, this line does nothing!\n\n        \nDialog\n \n=\n \ndialog\n\n    \n})\n\n\nend",
            "title": "Portals"
        },
        {
            "location": "/advanced/portals/#portals",
            "text": "Portals  are a special kind of component provided by Roact that enable components to render objects into a separate, non-Roact Instance.   Info  Eventually, there will be a diagram of Roact portals here. For now, just imagine Valve's hit game,  Portal .   To create a portal, use the  Roact.Portal  component with  createElement :  local   function   PartInWorkspace ( props ) \n     return   Roact . createElement ( Roact . Portal ,   { \n         target   =   Workspace \n     },   { \n         SomePart   =   Roact . createElement ( \"Part\" ,   { \n             Anchored   =   true \n         }) \n     })  end   When we create  PartInWorkspace , even if it's deep into our Roact tree, a  Part  Instance named  SomePart  will be created in  Workspace .   Warning  Portals should only be created to objects that aren't managed by Roact!   One particularly good use for portals is full-screen modal dialogs. When we render a modal dialog, we want it to take over the entire screen, but we want components deep in the tree to be able to create them!  local   PlayerGui   =   game : GetService ( \"Players\" ). LocalPlayer . PlayerGui  -- Our Modal component is a standard component, but with a portal at the top!  local   function   Modal ( props ) \n     return   Roact . createElement ( Roact . Portal ,   { \n         target   =   PlayerGui \n     },   { \n         Modal   =   Roact . createElement ( \"ScreenGui\" ,   {},   { \n             Label   =   Roact . createElement ( \"TextButton\" ,   { \n                 Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n                 Text   =   \"Click me to close!\" , \n\n                 [ Roact . Event . Activated ]   =   function () \n                     props . onClose () \n                 end \n             }) \n         }) \n     })  end  -- A ModalButton contains a little bit of state to decide whether the dialog  -- should be open or not.  local   ModalButton   =   Roact . Component : extend ( \"ModalButton\" )  function   ModalButton : init () \n     self . state   =   { \n         dialogOpen   =   false \n     }  end  function   ModalButton : render () \n     local   dialog   =   nil \n\n     -- If the dialog isn't open, just avoid rendering it. \n     if   self . state . dialogOpen   then \n         dialog   =   Roact . createElement ( Modal ,   { \n             onClose   =   function () \n                 self : setState ({ \n                     dialogOpen   =   false \n                 }) \n             end \n         }) \n     end \n\n     return   Roact . createElement ( \"TextButton\" ,   { \n         Size   =   UDim2 . new ( 0 ,   400 ,   0 ,   300 ), \n         Text   =   \"Click me to open modal dialog!\" , \n\n         [ Roact . Event . Activated ]   =   function () \n             self : setState ({ \n                 dialogOpen   =   true \n             }) \n         end \n     },   { \n         -- If `dialog` ends up nil, this line does nothing! \n         Dialog   =   dialog \n     })  end",
            "title": "Portals"
        },
        {
            "location": "/advanced/refs/",
            "text": "Refs\n\u00b6\n\n\nRefs\n grant access to the actual Instance objects that are created by Roact. They're an escape hatch for when something is difficult or impossible to correctly express with the Roact API.\n\n\nTo create a ref, pass a function prop with the key \nRoact.Ref\n when creating a primitive element:\n\n\nlocal\n \nframe\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"Ref was called with\"\n,\n \nrbx\n,\n \n\"of type\"\n,\n \ntypeof\n(\nrbx\n))\n\n    \nend\n\n\n})\n\n\n\nlocal\n \nhandle\n \n=\n \nRoact\n.\nreify\n(\nframe\n)\n\n\n\n-- Output:\n\n\n--     Ref was called with Frame of type Instance\n\n\n\nRoact\n.\nteardown\n(\nhandle\n)\n\n\n\n-- In the output:\n\n\n--     Ref was called with nil of type nil\n\n\n\n\n\n\n\n\nInfo\n\n\nRefs can only be used with primitive components.\n\n\n\n\n\n\nWarning\n\n\nWhen a component instance is destroyed or the ref property changes, \nnil\n will be passed to the old ref function!",
            "title": "Refs"
        },
        {
            "location": "/advanced/refs/#refs",
            "text": "Refs  grant access to the actual Instance objects that are created by Roact. They're an escape hatch for when something is difficult or impossible to correctly express with the Roact API.  To create a ref, pass a function prop with the key  Roact.Ref  when creating a primitive element:  local   frame   =   Roact . createElement ( \"Frame\" ,   { \n     [ Roact . Ref ]   =   function ( rbx ) \n         print ( \"Ref was called with\" ,   rbx ,   \"of type\" ,   typeof ( rbx )) \n     end  })  local   handle   =   Roact . reify ( frame )  -- Output:  --     Ref was called with Frame of type Instance  Roact . teardown ( handle )  -- In the output:  --     Ref was called with nil of type nil    Info  Refs can only be used with primitive components.    Warning  When a component instance is destroyed or the ref property changes,  nil  will be passed to the old ref function!",
            "title": "Refs"
        },
        {
            "location": "/advanced/context/",
            "text": "Context\n\u00b6\n\n\n\n\nWarning\n\n\nContext is an unstable feature that's being \nsignificantly\n revised. See \nissue #4\n for current progress.\n\n\n\n\n\n\nInfo\n\n\nThis section is incomplete. It's possible that the context API will change before the existing API is ever documented.",
            "title": "Context"
        },
        {
            "location": "/advanced/context/#context",
            "text": "Warning  Context is an unstable feature that's being  significantly  revised. See  issue #4  for current progress.    Info  This section is incomplete. It's possible that the context API will change before the existing API is ever documented.",
            "title": "Context"
        },
        {
            "location": "/api-reference/",
            "text": "Roact API Reference\n\u00b6\n\n\nMethods\n\u00b6\n\n\nRoact.createElement\n\u00b6\n\n\nRoact.createElement(component, [props, [children]]) -> RoactElement\n\n\n\n\n\nCreates a new Roact element representing the given \ncomponent\n.\n\n\nThe \nchildren\n argument is shorthand for adding a \nRoact.Children\n key to \nprops\n. It should be specified as a dictionary of names to elements.\n\n\ncomponent\n can be a string, a function, or a table created by \nComponent:extend\n.\n\n\n\n\nCaution\n\n\nOnce \nprops\n or \nchildren\n are passed into the \ncreateElement\n, make sure not to modify them!\n\n\n\n\nRoact.reify\n\u00b6\n\n\nRoact.reify(element, [parent, [key]]) -> ComponentInstanceHandle\n\n\n\n\n\nCreates a Roblox Instance given a Roact element, and optionally a \nparent\n to put it in, and a \nkey\n to use as the instance's \nName\n.\n\n\nThe result is a \nComponentInstanceHandle\n, which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like \nRoact.teardown\n and the future debug API.\n\n\nRoact.reconcile\n\u00b6\n\n\nRoact.reconcile(instanceHandle, element) -> ComponentInstanceHandle\n\n\n\n\n\nUpdates an existing instance handle with a new element, returning a new handle.\n\n\nreconcile\n can be used to change the props of a component instance created with \nreify\n and is useful for putting Roact content into non-Roact applications.\n\n\n\n\nWarning\n\n\nRoact.reconcile\n takes ownership of the \ninstanceHandle\n passed into it and may tear it down and create a new tree!\n\n\nMake sure to use the handle that \nreconcile\n returns in any operations after \nreconcile\n, including \nteardown\n.\n\n\n\n\nRoact.teardown\n\u00b6\n\n\nRoact.teardown(instance) -> void\n\n\n\n\n\nDestroys the given \nComponentInstanceHandle\n and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by \nRoact.reify\n.\n\n\nRoact.oneChild\n\u00b6\n\n\nRoact.oneChild(children) -> RoactElement | nil\n\n\nGiven a dictionary of children, returns a single child element.\n\n\nIf \nchildren\n contains more than one child, \noneChild\n function will throw an error. This is intended to denote an error when using the component using \noneChild\n.\n\n\nIf \nchildren\n is \nnil\n or contains no children, \noneChild\n will return \nnil\n.\n\n\nConstants\n\u00b6\n\n\nRoact.Children\n\u00b6\n\n\nThis is the key that Roact uses internally to store the children that are attached to a Roact element.\n\n\nIf you're writing a new functional or stateful element that needs to be used like a primitive component, you can access \nRoact.Children\n in your props table.\n\n\nRoact.Ref\n\u00b6\n\n\nUse \nRoact.Ref\n as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance.\n\n\nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \nprint\n(\n\"Roblox Instance\"\n,\n \nrbx\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\n\n\nWarning\n\n\nRoact.Ref\n will be called with \nnil\n when the component instance is destroyed!\n\n\n\n\nSee \nthe refs guide\n for more details.\n\n\nRoact.Event\n\u00b6\n\n\nIndex into \nRoact.Event\n to receive a key that can be used to connect to events when creating primitive elements:\n\n\nRoact\n.\ncreateElement\n(\n\"ImageButton\"\n,\n \n{\n\n    \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n(\nrbx\n,\n \nx\n,\n \ny\n)\n\n        \nprint\n(\nrbx\n,\n \n\"clicked at position\"\n,\n \nx\n,\n \ny\n)\n\n    \nend\n,\n\n\n})\n\n\n\n\n\n\n\n\nInfo\n\n\nEvent callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.\n\n\n\n\nSee \nthe events guide\n for more details.\n\n\nComponent Types\n\u00b6\n\n\nRoact.Component\n\u00b6\n\n\nThe base component instance that can be extended to make stateful components.\n\n\nCall \nRoact.Component:extend(\"ComponentName\")\n to make a new stateful component with a given name.\n\n\nRoact.PureComponent\n\u00b6\n\n\nAn extension of \nRoact.Component\n that only re-renders if its props or state change.\n\n\nPureComponent\n implements the \nshouldUpdate\n lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux.\n\n\nPureComponent\n is not \nalways\n faster, but can often result in significant performance improvements when used correctly.\n\n\nRoact.Portal\n\u00b6\n\n\nA component that represents a \nportal\n to a Roblox Instance. Portals are created using \nRoact.createElement\n.\n\n\nAny children of a portal are put inside the Roblox Instance specified by the required \ntarget\n prop. That Roblox Instance should not be one created by Roact.\n\n\nPortals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once.\n\n\nSee \nthe Portals guide\n for a small tutorial and more details about portals.\n\n\nComponent API\n\u00b6\n\n\ninit\n\u00b6\n\n\ninit(initialProps) -> void\n\n\n\n\n\ninit\n is called exactly once when a new instance of a component is created. It can be used to set up the initial \nstate\n, as well as any non-\nrender\n related values directly on the component.\n\n\ninit\n is the only place where you can assign to \nstate\n directly, as opposed to using \nsetState\n:\n\n\nfunction\n \nMyComponent\n:\ninit\n()\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \nposition\n \n=\n \n0\n,\n\n        \nvelocity\n \n=\n \n10\n\n    \n}\n\n\nend\n\n\n\n\n\n\nrender\n\u00b6\n\n\nrender() -> Element | nil\n\n\n\n\n\nrender\n describes what a component should display at the current instant in time.\n\n\n\n\nInfo\n\n\nRoact assumes that \nrender\n act likes a pure function: the result of \nrender\n must depend only on \nprops\n and \nstate\n, and it must not have side-effects.\n\n\n\n\nfunction\n \nMyComponent\n:\nrender\n()\n\n    \n-- This is okay:\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \nself\n.\nprops\n.\ntext\n,\n\n        \nPosition\n \n=\n \nself\n.\nstate\n.\nposition\n\n    \n})\n\n\n    \n-- Ack! Depending on values outside props/state is not allowed!\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \nself\n.\nsomeText\n,\n\n        \nPosition\n \n=\n \ngetMousePosition\n(),\n\n    \n})\n\n\nend\n\n\n\n\n\n\nrender\n must be defined for all components. The default implementation of \nrender\n throws an error; if your component does not render anything, define a render function that returns \nnil\n explicitly.\n\n\nfunction\n \nMyComponent\n:\nrender\n()\n\n    \nreturn\n \nnil\n\n\nend\n\n\n\n\n\n\nsetState\n\u00b6\n\n\nsetState(newState) -> void\n\n\n\n\n\nsetState\n merges a table of new state values (\nnewState\n) onto the existing \nstate\n and re-renders the component if necessary. Existing values are not affected.\n\n\nfunction\n \nMyComponent\n:\ndidMount\n()\n\n    \nself\n:\nsetState\n({\n\n        \nfoo\n \n=\n \n\"bar\"\n\n    \n})\n\n\nend\n\n\n\n\n\n\n\n\nWarning\n\n\nCalling \nsetState\n from any of these places is not allowed and will throw an error:\n\n\n\n\nLifecycle hooks: \nwillUpdate\n, \nwillUnmount\n\n\nInitialization: \ninit\n\n\nPure functions: \nrender\n, \nshouldUpdate\n\n\n\n\n\n\n\n\nFuture API Changes\n\n\nDepending on current \nstate\n in \nsetState\n may cause subtle bugs when Roact starts supporting \nasynchronous rendering\n.\n\n\nA new API similar to React \nis being introduced\n to solve this problem. This documentation will be updated when that API is released.\n\n\n\n\nshouldUpdate\n\u00b6\n\n\nshouldUpdate(nextProps, nextState) -> bool\n\n\n\n\n\nshouldUpdate\n provides a way to override Roact's rerendering heuristics.\n\n\nRight now, components are re-rendered any time a parent component updates, or when state is updated via \nsetState\n.\n\n\nPureComponent\n implements \nshouldUpdate\n to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update, \nall\n components may implement this check by default.\n\n\nLifecycle Events\n\u00b6\n\n\nRoact exposes a number of events that stateful components can hook into to be notified of various steps in the rendering process.\n\n\nMounting:\n\n\n\n    \ninit\n\n    \n\u279d\n\n    \nrender\n\n    \n\u279d\n\n    \ndidMount\n\n\n\n\n\nUpdating:\n\n\n\n    \nshouldUpdate?\n\n    \n\u279d\n\n    \nwillUpdate\n\n    \n\u279d\n\n    \nrender\n\n    \n\u279d\n\n    \ndidUpdate\n\n\n\n\n\nUnmounting:\n\n\n\n    \nwillUnmount\n\n\n\n\n\ndidMount\n\u00b6\n\n\ndidMount() -> void\n\n\n\n\n\ndidMount\n is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting.\n\n\ndidMount\n is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.\n\n\nwillUnmount\n\u00b6\n\n\nwillUnmount() -> void\n\n\n\n\n\nwillUnmount\n is fired right before Roact begins tearing down a component instance's children.\n\n\nwillUnmount\n acts like a component's destructor, and is a good place to disconnect any manually-connected events.\n\n\nwillUpdate\n\u00b6\n\n\nwillUpdate(nextProps, nextState) -> void\n\n\n\n\n\nwillUpdate\n is fired after an update is started but before a component's state and props are updated.\n\n\ndidUpdate\n\u00b6\n\n\ndidUpdate(previousProps, previousState) -> void\n\n\n\n\n\ndidUpdate\n is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date.\n\n\ndidUpdate\n is a good place to send network requests or dispatch Rodux actions, but make sure to compare \nself.props\n and \nself.state\n with \npreviousProps\n and \npreviousState\n to avoid triggering too many updates.",
            "title": "API Reference"
        },
        {
            "location": "/api-reference/#roact-api-reference",
            "text": "",
            "title": "Roact API Reference"
        },
        {
            "location": "/api-reference/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api-reference/#roactcreateelement",
            "text": "Roact.createElement(component, [props, [children]]) -> RoactElement  Creates a new Roact element representing the given  component .  The  children  argument is shorthand for adding a  Roact.Children  key to  props . It should be specified as a dictionary of names to elements.  component  can be a string, a function, or a table created by  Component:extend .   Caution  Once  props  or  children  are passed into the  createElement , make sure not to modify them!",
            "title": "Roact.createElement"
        },
        {
            "location": "/api-reference/#roactreify",
            "text": "Roact.reify(element, [parent, [key]]) -> ComponentInstanceHandle  Creates a Roblox Instance given a Roact element, and optionally a  parent  to put it in, and a  key  to use as the instance's  Name .  The result is a  ComponentInstanceHandle , which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like  Roact.teardown  and the future debug API.",
            "title": "Roact.reify"
        },
        {
            "location": "/api-reference/#roactreconcile",
            "text": "Roact.reconcile(instanceHandle, element) -> ComponentInstanceHandle  Updates an existing instance handle with a new element, returning a new handle.  reconcile  can be used to change the props of a component instance created with  reify  and is useful for putting Roact content into non-Roact applications.   Warning  Roact.reconcile  takes ownership of the  instanceHandle  passed into it and may tear it down and create a new tree!  Make sure to use the handle that  reconcile  returns in any operations after  reconcile , including  teardown .",
            "title": "Roact.reconcile"
        },
        {
            "location": "/api-reference/#roactteardown",
            "text": "Roact.teardown(instance) -> void  Destroys the given  ComponentInstanceHandle  and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by  Roact.reify .",
            "title": "Roact.teardown"
        },
        {
            "location": "/api-reference/#roactonechild",
            "text": "Roact.oneChild(children) -> RoactElement | nil  Given a dictionary of children, returns a single child element.  If  children  contains more than one child,  oneChild  function will throw an error. This is intended to denote an error when using the component using  oneChild .  If  children  is  nil  or contains no children,  oneChild  will return  nil .",
            "title": "Roact.oneChild"
        },
        {
            "location": "/api-reference/#constants",
            "text": "",
            "title": "Constants"
        },
        {
            "location": "/api-reference/#roactchildren",
            "text": "This is the key that Roact uses internally to store the children that are attached to a Roact element.  If you're writing a new functional or stateful element that needs to be used like a primitive component, you can access  Roact.Children  in your props table.",
            "title": "Roact.Children"
        },
        {
            "location": "/api-reference/#roactref",
            "text": "Use  Roact.Ref  as a key into the props of a primitive element to receive a handle to the underlying Roblox Instance.  Roact . createElement ( \"Frame\" ,   { \n     [ Roact . Ref ]   =   function ( rbx ) \n         print ( \"Roblox Instance\" ,   rbx ) \n     end ,  })    Warning  Roact.Ref  will be called with  nil  when the component instance is destroyed!   See  the refs guide  for more details.",
            "title": "Roact.Ref"
        },
        {
            "location": "/api-reference/#roactevent",
            "text": "Index into  Roact.Event  to receive a key that can be used to connect to events when creating primitive elements:  Roact . createElement ( \"ImageButton\" ,   { \n     [ Roact . Event . MouseButton1Click ]   =   function ( rbx ,   x ,   y ) \n         print ( rbx ,   \"clicked at position\" ,   x ,   y ) \n     end ,  })    Info  Event callbacks receive the Roblox Instance as the first parameter, followed by any parameters yielded by the event.   See  the events guide  for more details.",
            "title": "Roact.Event"
        },
        {
            "location": "/api-reference/#component-types",
            "text": "",
            "title": "Component Types"
        },
        {
            "location": "/api-reference/#roactcomponent",
            "text": "The base component instance that can be extended to make stateful components.  Call  Roact.Component:extend(\"ComponentName\")  to make a new stateful component with a given name.",
            "title": "Roact.Component"
        },
        {
            "location": "/api-reference/#roactpurecomponent",
            "text": "An extension of  Roact.Component  that only re-renders if its props or state change.  PureComponent  implements the  shouldUpdate  lifecycle event with a shallow equality comparison. It's optimized for use with immutable data structures, which makes it a perfect fit for use with frameworks like Rodux.  PureComponent  is not  always  faster, but can often result in significant performance improvements when used correctly.",
            "title": "Roact.PureComponent"
        },
        {
            "location": "/api-reference/#roactportal",
            "text": "A component that represents a  portal  to a Roblox Instance. Portals are created using  Roact.createElement .  Any children of a portal are put inside the Roblox Instance specified by the required  target  prop. That Roblox Instance should not be one created by Roact.  Portals are useful for creating dialogs managed by deeply-nested UI components, and enable Roact to represent and manage multiple disjoint trees at once.  See  the Portals guide  for a small tutorial and more details about portals.",
            "title": "Roact.Portal"
        },
        {
            "location": "/api-reference/#component-api",
            "text": "",
            "title": "Component API"
        },
        {
            "location": "/api-reference/#init",
            "text": "init(initialProps) -> void  init  is called exactly once when a new instance of a component is created. It can be used to set up the initial  state , as well as any non- render  related values directly on the component.  init  is the only place where you can assign to  state  directly, as opposed to using  setState :  function   MyComponent : init () \n     self . state   =   { \n         position   =   0 , \n         velocity   =   10 \n     }  end",
            "title": "init"
        },
        {
            "location": "/api-reference/#render",
            "text": "render() -> Element | nil  render  describes what a component should display at the current instant in time.   Info  Roact assumes that  render  act likes a pure function: the result of  render  must depend only on  props  and  state , and it must not have side-effects.   function   MyComponent : render () \n     -- This is okay: \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   self . props . text , \n         Position   =   self . state . position \n     }) \n\n     -- Ack! Depending on values outside props/state is not allowed! \n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   self . someText , \n         Position   =   getMousePosition (), \n     })  end   render  must be defined for all components. The default implementation of  render  throws an error; if your component does not render anything, define a render function that returns  nil  explicitly.  function   MyComponent : render () \n     return   nil  end",
            "title": "render"
        },
        {
            "location": "/api-reference/#setstate",
            "text": "setState(newState) -> void  setState  merges a table of new state values ( newState ) onto the existing  state  and re-renders the component if necessary. Existing values are not affected.  function   MyComponent : didMount () \n     self : setState ({ \n         foo   =   \"bar\" \n     })  end    Warning  Calling  setState  from any of these places is not allowed and will throw an error:   Lifecycle hooks:  willUpdate ,  willUnmount  Initialization:  init  Pure functions:  render ,  shouldUpdate     Future API Changes  Depending on current  state  in  setState  may cause subtle bugs when Roact starts supporting  asynchronous rendering .  A new API similar to React  is being introduced  to solve this problem. This documentation will be updated when that API is released.",
            "title": "setState"
        },
        {
            "location": "/api-reference/#shouldupdate",
            "text": "shouldUpdate(nextProps, nextState) -> bool  shouldUpdate  provides a way to override Roact's rerendering heuristics.  Right now, components are re-rendered any time a parent component updates, or when state is updated via  setState .  PureComponent  implements  shouldUpdate  to only trigger a re-render any time the props are different based on shallow equality. In a future Roact update,  all  components may implement this check by default.",
            "title": "shouldUpdate"
        },
        {
            "location": "/api-reference/#lifecycle-events",
            "text": "Roact exposes a number of events that stateful components can hook into to be notified of various steps in the rendering process.  Mounting:  \n     init \n     \u279d \n     render \n     \u279d \n     didMount   Updating:  \n     shouldUpdate? \n     \u279d \n     willUpdate \n     \u279d \n     render \n     \u279d \n     didUpdate   Unmounting:  \n     willUnmount",
            "title": "Lifecycle Events"
        },
        {
            "location": "/api-reference/#didmount",
            "text": "didMount() -> void  didMount  is fired after the component finishes its initial render. At this point, all associated Roblox Instances have been created, and all components have finished mounting.  didMount  is a good place to start initial network communications, attach events to services, or modify the Roblox Instance hierarchy.",
            "title": "didMount"
        },
        {
            "location": "/api-reference/#willunmount",
            "text": "willUnmount() -> void  willUnmount  is fired right before Roact begins tearing down a component instance's children.  willUnmount  acts like a component's destructor, and is a good place to disconnect any manually-connected events.",
            "title": "willUnmount"
        },
        {
            "location": "/api-reference/#willupdate",
            "text": "willUpdate(nextProps, nextState) -> void  willUpdate  is fired after an update is started but before a component's state and props are updated.",
            "title": "willUpdate"
        },
        {
            "location": "/api-reference/#didupdate",
            "text": "didUpdate(previousProps, previousState) -> void  didUpdate  is fired after at the end of an update. At this point, the reconciler has updated the properties of any Roblox Instances and the component instance's props and state are up to date.  didUpdate  is a good place to send network requests or dispatch Rodux actions, but make sure to compare  self.props  and  self.state  with  previousProps  and  previousState  to avoid triggering too many updates.",
            "title": "didUpdate"
        }
    ]
}