{
    "docs": [
        {
            "location": "/",
            "text": "Home\n\u00b6\n\n\nRoact is a declarative Lua UI library intended to mirror Facebook's React. It exposes a very similar API to React and implements nearly identical semantics.\n\n\nThis documentation assumes that the reader has some familiarity with the Roblox API but no experience with React.",
            "title": "Home"
        },
        {
            "location": "/#home",
            "text": "Roact is a declarative Lua UI library intended to mirror Facebook's React. It exposes a very similar API to React and implements nearly identical semantics.  This documentation assumes that the reader has some familiarity with the Roblox API but no experience with React.",
            "title": "Home"
        },
        {
            "location": "/what-is-roact/",
            "text": "What is Roact?\n\u00b6\n\n\nRoact is a \ndeclarative\n UI library for Roblox.\n\n\nWhat does this mean exactly?\n\n\nA Simple Problem\n\u00b6\n\n\nNormally, when you build a UI in Roblox (or a lot of systems), you create some objects and set some properties on them:\n\n\nlocal\n \nuserName\n \n=\n \n\"UristMcSparks\"\n\n\n\nlocal\n \nuserLabel\n \n=\n \nInstance\n.\nnew\n(\n\"TextLabel\"\n)\n\n\nuserLabel\n.\nText\n \n=\n \nuserName\n\n\n\n-- The text is as red as it is long\n\n\nuserLabel\n.\nTextColor3\n \n=\n \nColor3\n.\nfromRGB\n(\n#\nuserName\n,\n \n0\n,\n \n0\n)\n\n\n\n\n\n\nAnd then when you have some sort of state change, you just change your object based on your data:\n\n\nuserName\n \n=\n \n\"OnlyTwentyCharacters\"\n\n\n\nuserLabel\n.\nText\n \n=\n \nuserName\n\n\nuserLabel\n.\nTextColor3\n \n=\n \nColor3\n.\nfromRGB\n(\n#\nuserName\n,\n \n0\n,\n \n255\n)\n\n\n\n\n\n\nNow we have to remember to update \nuserLabel\n every time \nuserName\n changes! Augh!\n\n\nMore than that, you have to think about \ncreating\n and \nupdating\n your object separately. The code lives in two places, and if we change one, we can forget to the change the other.\n\n\nLet's focus on solving the second problem.\n\n\nOne possibility is that we just throw away \nuserLabel\n every time there's an update, and have users call a new function, \nsetUserName\n, to update it.\n\n\nlocal\n \nfunction\n \nmakeLabel\n(\nname\n)\n\n    \nlocal\n \nlabel\n \n=\n \nInstance\n.\nnew\n(\n\"TextLabel\"\n)\n\n    \nlabel\n.\nText\n \n=\n \nname\n\n    \nlabel\n.\nTextColor3\n \n=\n \nColor3\n.\nfromRGB\n(\n#\nname\n,\n \n0\n,\n \n0\n)\n\n\n    \nreturn\n \nlabel\n\n\nend\n\n\n\nlocal\n \nuserLabel\n \n=\n \nmakeLabel\n(\n\"UristMcSparks\"\n)\n\n\n\nlocal\n \nfunction\n \nsetUserName\n(\nname\n)\n\n    \nuserLabel\n:\nDestroy\n()\n\n    \nuserLabel\n \n=\n \nmakeLabel\n(\nname\n)\n\n\nend\n\n\n\n\n\n\nThis functions in our simple case pretty well. There's no chance that we'll mess up the \nchange\n part of our UI, but we gain some new problems!\n\n\nWe're creating a lot of garbage; you can't get away with this for a big UI. All we \nreally\n wanted to do was change a couple of properties, not make a whole new object.\n\n\nWhen building the new Lua chat on iOS, this is the approach that was taken for most \nsmall\n components. It introduced some performance problems, but did make the code drastically simpler in many cases.\n\n\nThis is where Roact helps. It lets you write code similar to the \nmakeLabel\n function, without having any of the downsides:\n\n\nlocal\n \nfunction\n \nUserLabel\n(\nprops\n)\n\n    \nlocal\n \nname\n \n=\n \nprops\n.\nname\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \nname\n,\n\n        \nTextColor3\n \n=\n \nColor3\n.\nfromRGB\n(\n#\nname\n,\n \n0\n,\n \n0\n),\n\n    \n})\n\n\nend\n\n\n\n\n\n\nWhat we've done here is create a \nfunctional component\n. It stands in for the \nmakeLabel\n function above.\n\n\nFrom here, you can hook \nUserLabel\n up to Rodux and it will automatically stay in sync with whatever your user label is, without creating a bunch of junk!\n\n\nThe code to do that hookup isn't that bad, either:\n\n\nlocal\n \nCurrentUserLabel\n \n=\n \nRoactRodux\n.\nconnect\n(\nfunction\n(\nstore\n)\n\n    \n-- We get access to a Rodux store and return props for our component\n\n    \nlocal\n \nstate\n \n=\n \nstore\n:\nGetState\n()\n\n\n    \nreturn\n \n{\n\n        \nname\n \n=\n \nstate\n.\ncurrentUser\n,\n\n    \n}\n\n\nend\n)\n\n\n\n\n\n\nA Less Simple Problem: Lists\n\u00b6\n\n\nAs a more complicated example, what about trying to show a list of users?\n\n\nWithout any fancy libraries:\n\n\nlocal\n \nusers\n \n=\n \n{\n\"Alice\"\n,\n \n\"Bob\"\n,\n \n\"Carol\"\n,\n \n\"Dave\"\n,\n \n\"Eric\"\n,\n \n\"Freddy\"\n,\n \n\"Gale\"\n,\n \n\"Havve\"\n}\n\n\n\nlocal\n \nfunction\n \nmakeLabels\n(\nusers\n)\n\n    \nlocal\n \ncontainer\n \n=\n \nInstance\n.\nnew\n(\n\"Frame\"\n)\n\n\n    \n-- Lay our users out in a list\n\n    \nlocal\n \nlayout\n \n=\n \nInstance\n.\nnew\n(\n\"UIListLayout\"\n)\n\n    \nlayout\n.\nSortOrder\n \n=\n \nEnum\n.\nSortOrder\n.\nLayoutOrder\n\n    \nlayout\n.\nParent\n \n=\n \ncontainer\n\n\n    \nfor\n \nindex\n,\n \nuser\n \nin\n \nipairs\n(\nusers\n)\n \ndo\n\n        \nlocal\n \nuserLabel\n \n=\n \nInstance\n.\nnew\n(\n\"TextLabel\"\n)\n\n        \nuserLabel\n.\nText\n \n=\n \nuser\n\n        \nuserLabel\n.\nLayoutOrder\n \n=\n \nindex\n\n        \nuserLabel\n.\nParent\n \n=\n \ncontainer\n\n    \nend\n\n\n    \nreturn\n \ncontainer\n\n\nend\n\n\n\nlocal\n \nfunction\n \nupdateUsers\n(\nusers\n)\n\n    \n-- uh oh...\n\n\nend\n\n\n\n\n\n\nNow we run into a roadblock. How do we update the UI with a new list of users?\n\n\nWe could throw away the entire UI like in the previous example, but even with just 8 users, that's a lot of waste.\n\n\nIn Lua chat for iOS, we hit this problem but had dozens to \nhundreds\n of entries in our lists. Messages could be inserted or changed anywhere in the list, so we had to handle every possible mutation gracefully and generically.\n\n\nIn that case, we wrote code to traverse the old and new \nusers\n lists, comparing values and order, manually replacing elements where things differed.\n\n\nRoact can give us a hand with this problem:\n\n\nlocal\n \nfunction\n \nUserLabels\n(\nprops\n)\n\n    \nlocal\n \nusers\n \n=\n \nprops\n.\nusers\n\n\n    \nlocal\n \nchildren\n \n=\n \n{}\n\n\n    \nfor\n \nindex\n,\n \nuser\n \nin\n \nipairs\n(\nusers\n)\n \ndo\n\n        \nlocal\n \nuserElement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nText\n \n=\n \nuser\n,\n\n            \nLayoutOrder\n \n=\n \nindex\n,\n\n        \n})\n\n\n        \nchildren\n[\n\"User-\"\n \n..\n \nuser\n]\n \n=\n \nuserElement\n\n    \nend\n\n\n    \nchildren\n.\nLayout\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n,\n \n{\n\n        \nSortOrder\n \n=\n \nEnum\n.\nSortOrder\n.\nLayoutOrder\n,\n\n    \n})\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{},\n \nchildren\n)\n\n\nend\n\n\n\n\n\n\nThat's it. Roact will deal with any changes to the list of users, and there's no chance that the list will be out of sync with the data that Roact was given.",
            "title": "What is Roact?"
        },
        {
            "location": "/what-is-roact/#what-is-roact",
            "text": "Roact is a  declarative  UI library for Roblox.  What does this mean exactly?",
            "title": "What is Roact?"
        },
        {
            "location": "/what-is-roact/#a-simple-problem",
            "text": "Normally, when you build a UI in Roblox (or a lot of systems), you create some objects and set some properties on them:  local   userName   =   \"UristMcSparks\"  local   userLabel   =   Instance . new ( \"TextLabel\" )  userLabel . Text   =   userName  -- The text is as red as it is long  userLabel . TextColor3   =   Color3 . fromRGB ( # userName ,   0 ,   0 )   And then when you have some sort of state change, you just change your object based on your data:  userName   =   \"OnlyTwentyCharacters\"  userLabel . Text   =   userName  userLabel . TextColor3   =   Color3 . fromRGB ( # userName ,   0 ,   255 )   Now we have to remember to update  userLabel  every time  userName  changes! Augh!  More than that, you have to think about  creating  and  updating  your object separately. The code lives in two places, and if we change one, we can forget to the change the other.  Let's focus on solving the second problem.  One possibility is that we just throw away  userLabel  every time there's an update, and have users call a new function,  setUserName , to update it.  local   function   makeLabel ( name ) \n     local   label   =   Instance . new ( \"TextLabel\" ) \n     label . Text   =   name \n     label . TextColor3   =   Color3 . fromRGB ( # name ,   0 ,   0 ) \n\n     return   label  end  local   userLabel   =   makeLabel ( \"UristMcSparks\" )  local   function   setUserName ( name ) \n     userLabel : Destroy () \n     userLabel   =   makeLabel ( name )  end   This functions in our simple case pretty well. There's no chance that we'll mess up the  change  part of our UI, but we gain some new problems!  We're creating a lot of garbage; you can't get away with this for a big UI. All we  really  wanted to do was change a couple of properties, not make a whole new object.  When building the new Lua chat on iOS, this is the approach that was taken for most  small  components. It introduced some performance problems, but did make the code drastically simpler in many cases.  This is where Roact helps. It lets you write code similar to the  makeLabel  function, without having any of the downsides:  local   function   UserLabel ( props ) \n     local   name   =   props . name \n\n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   name , \n         TextColor3   =   Color3 . fromRGB ( # name ,   0 ,   0 ), \n     })  end   What we've done here is create a  functional component . It stands in for the  makeLabel  function above.  From here, you can hook  UserLabel  up to Rodux and it will automatically stay in sync with whatever your user label is, without creating a bunch of junk!  The code to do that hookup isn't that bad, either:  local   CurrentUserLabel   =   RoactRodux . connect ( function ( store ) \n     -- We get access to a Rodux store and return props for our component \n     local   state   =   store : GetState () \n\n     return   { \n         name   =   state . currentUser , \n     }  end )",
            "title": "A Simple Problem"
        },
        {
            "location": "/what-is-roact/#a-less-simple-problem-lists",
            "text": "As a more complicated example, what about trying to show a list of users?  Without any fancy libraries:  local   users   =   { \"Alice\" ,   \"Bob\" ,   \"Carol\" ,   \"Dave\" ,   \"Eric\" ,   \"Freddy\" ,   \"Gale\" ,   \"Havve\" }  local   function   makeLabels ( users ) \n     local   container   =   Instance . new ( \"Frame\" ) \n\n     -- Lay our users out in a list \n     local   layout   =   Instance . new ( \"UIListLayout\" ) \n     layout . SortOrder   =   Enum . SortOrder . LayoutOrder \n     layout . Parent   =   container \n\n     for   index ,   user   in   ipairs ( users )   do \n         local   userLabel   =   Instance . new ( \"TextLabel\" ) \n         userLabel . Text   =   user \n         userLabel . LayoutOrder   =   index \n         userLabel . Parent   =   container \n     end \n\n     return   container  end  local   function   updateUsers ( users ) \n     -- uh oh...  end   Now we run into a roadblock. How do we update the UI with a new list of users?  We could throw away the entire UI like in the previous example, but even with just 8 users, that's a lot of waste.  In Lua chat for iOS, we hit this problem but had dozens to  hundreds  of entries in our lists. Messages could be inserted or changed anywhere in the list, so we had to handle every possible mutation gracefully and generically.  In that case, we wrote code to traverse the old and new  users  lists, comparing values and order, manually replacing elements where things differed.  Roact can give us a hand with this problem:  local   function   UserLabels ( props ) \n     local   users   =   props . users \n\n     local   children   =   {} \n\n     for   index ,   user   in   ipairs ( users )   do \n         local   userElement   =   Roact . createElement ( \"TextLabel\" ,   { \n             Text   =   user , \n             LayoutOrder   =   index , \n         }) \n\n         children [ \"User-\"   ..   user ]   =   userElement \n     end \n\n     children . Layout   =   Roact . createElement ( \"UIListLayout\" ,   { \n         SortOrder   =   Enum . SortOrder . LayoutOrder , \n     }) \n\n     return   Roact . createElement ( \"Frame\" ,   {},   children )  end   That's it. Roact will deal with any changes to the list of users, and there's no chance that the list will be out of sync with the data that Roact was given.",
            "title": "A Less Simple Problem: Lists"
        },
        {
            "location": "/getting-started/",
            "text": "Getting Started\n\u00b6\n\n\nThe simplest way to get started is to download an installer script from the \nRoact GitHub releases page\n.\n\n\nInstall it somewhere that's accessible by your code, and then load it using \nrequrie\n:\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Now you have Roact!",
            "title": "Getting Started"
        },
        {
            "location": "/getting-started/#getting-started",
            "text": "The simplest way to get started is to download an installer script from the  Roact GitHub releases page .  Install it somewhere that's accessible by your code, and then load it using  requrie :  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Now you have Roact!",
            "title": "Getting Started"
        },
        {
            "location": "/guide/elements-components/",
            "text": "Elements and Components\n\u00b6\n\n\nRoact is based entirely on the concept of reusable components. These components are then built up entirely of other components, creating a composable hierarchy that represents the UI of an application.\n\n\nElements\n\u00b6\n\n\nElements are directly created by a Roact application calling \nRoact.createElement\n. They represent the structure that should be presented at any given point.\n\n\nElements are immutable, fast to create, and replaceable. Creating an element has no side effects since all it does is describe what your UI should look like.\n\n\nComponents\n\u00b6\n\n\nComponents define what happens when your elements need to be translated to a real UI.\n\n\nThere are three types of component:\n\n Primitive\n\n Functional\n* Stateful\n\n\nRoact will take the tree of \nelements\n, which themselves specify what types of \ncomponent\n they represent. With that tree, it'll create \ncomponent instances\n, which represent a specific invocation of the UI.\n\n\nPrimitive Components\n\u00b6\n\n\nPrimitive components correlate one-to-one with Roblox Instances, like \nFrame\n, \nScreenGui\n, or \nPart\n objects.\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n    \nBackgroundColor3\n \n=\n \nColor3\n.\nnew\n(\n1\n,\n \n0\n,\n \n0\n),\n\n\n})\n\n\n\nRoact\n.\nreify\n(\nelement\n,\n \nCoreGui\n,\n \n\"Really Red Frame\"\n)\n\n\n\n\n\n\nThis code will create a \nFrame\n named \n\"Really Red Frame\"\n and stick it into \nCoreGui\n.\n\n\nPrimitive components are allowed to have multiple children, which can also turn into Roblox Instances:\n\n\nlocal\n \nlist\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n\n},\n \n{\n\n    \nLayout\n \n=\n \nRoact\n.\ncreateElement\n(\n\"UIListLayout\"\n),\n\n\n    \nA\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n),\n\n    \nB\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n),\n\n\n})\n\n\n\n\n\n\nWhen reified, this component would produce this Roblox hierarchy:\n\n\nFrame\n    - UIListLayout (named 'Layout')\n    - TextButton (named 'A')\n    - TextButton (named 'B')\n\n\n\n\n\nFunctional Components\n\u00b6\n\n\nFunctional components are just functions that take in some values (named \nprops\n), and return an element or \nnil\n.\n\n\nlocal\n \nfunction\n \nCoolLabel\n(\nprops\n)\n\n    \nlocal\n \ntext\n \n=\n \nprops\n.\ntext\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \ntext\n,\n\n    \n})\n\n\nend\n\n\n\n\n\n\nTo use them, just create an element that references one as your type, just like with primitive elements:\n\n\nlocal\n \nmyLabel\n \n=\n \nRoact\n.\ncreateElement\n(\nCoolLabel\n,\n \n{\n\n    \ntext\n \n=\n \n\"henlo my guys\"\n\n\n})\n\n\n\nRoact\n.\nreify\n(\nmyLabel\n,\n \nCoreGui\n,\n \n\"Hip Greeting\"\n)\n\n\n\n\n\n\nFunctional elements can have children too, you just have to explicitly access and use them:\n\n\nlocal\n \nfunction\n \nStuffContainer\n(\nprops\n)\n\n    \nlocal\n \nchildren\n \n=\n \nprops\n[\nRoact\n.\nChildren\n]\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n)\n\n    \n},\n \nchildren\n)\n\n\nend\n\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\nStuffContainer\n,\n \n{},\n \n{\n\n    \nA\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n),\n\n    \nB\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n),\n\n\n})\n\n\n\n\n\n\nWhen reified, \nelement\n would result in this Roblox hierarchy:\n\n\nFrame\n    - TextButton (named 'A')\n    - Frame (named 'B')\n\n\n\n\n\nStateful Components\n\u00b6\n\n\nFunctions are to classes as functional components are to stateful components.\n\n\nStateful components are very similar to functional components in that the meat of their code is just a function that returns an element or \nnil\n:\n\n\nlocal\n \nCoolLabel\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"CoolLabel\"\n)\n\n\n\nfunction\n \nCoolLabel\n:\nrender\n()\n\n    \nlocal\n \ntext\n \n=\n \nself\n.\nprops\n.\ntext\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \ntext\n\n    \n})\n\n\nend\n\n\n\n\n\n\nIt's important that the \nrender\n function in a stateful component \nonly\n uses values from \nprops\n and \nstate\n to determine what to render!\n\n\nThe primary difference here is that you call \nextend\n on \nRoact.Component\n, passing in a name to give to your new component. This name is used for debugging.\n\n\nStateful components also have a notion of state, which lets them keep track of their own data that can change. See \nthe 'counter' example\n for a good example of how to utilize state.\n\n\nHigher-Order Components (HOC)\n\u00b6\n\n\nA higher-order component (or HOC) is just a function that returns a component. It's a common pattern for APIs like Roact-Rodux that wrap an existing component with some extra features.",
            "title": "Elements and Components"
        },
        {
            "location": "/guide/elements-components/#elements-and-components",
            "text": "Roact is based entirely on the concept of reusable components. These components are then built up entirely of other components, creating a composable hierarchy that represents the UI of an application.",
            "title": "Elements and Components"
        },
        {
            "location": "/guide/elements-components/#elements",
            "text": "Elements are directly created by a Roact application calling  Roact.createElement . They represent the structure that should be presented at any given point.  Elements are immutable, fast to create, and replaceable. Creating an element has no side effects since all it does is describe what your UI should look like.",
            "title": "Elements"
        },
        {
            "location": "/guide/elements-components/#components",
            "text": "Components define what happens when your elements need to be translated to a real UI.  There are three types of component:  Primitive  Functional\n* Stateful  Roact will take the tree of  elements , which themselves specify what types of  component  they represent. With that tree, it'll create  component instances , which represent a specific invocation of the UI.",
            "title": "Components"
        },
        {
            "location": "/guide/elements-components/#primitive-components",
            "text": "Primitive components correlate one-to-one with Roblox Instances, like  Frame ,  ScreenGui , or  Part  objects.  local   element   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n     BackgroundColor3   =   Color3 . new ( 1 ,   0 ,   0 ),  })  Roact . reify ( element ,   CoreGui ,   \"Really Red Frame\" )   This code will create a  Frame  named  \"Really Red Frame\"  and stick it into  CoreGui .  Primitive components are allowed to have multiple children, which can also turn into Roblox Instances:  local   list   =   Roact . createElement ( \"Frame\" ,   { \n     Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ),  },   { \n     Layout   =   Roact . createElement ( \"UIListLayout\" ), \n\n     A   =   Roact . createElement ( \"TextButton\" ), \n     B   =   Roact . createElement ( \"TextButton\" ),  })   When reified, this component would produce this Roblox hierarchy:  Frame\n    - UIListLayout (named 'Layout')\n    - TextButton (named 'A')\n    - TextButton (named 'B')",
            "title": "Primitive Components"
        },
        {
            "location": "/guide/elements-components/#functional-components",
            "text": "Functional components are just functions that take in some values (named  props ), and return an element or  nil .  local   function   CoolLabel ( props ) \n     local   text   =   props . text \n\n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   text , \n     })  end   To use them, just create an element that references one as your type, just like with primitive elements:  local   myLabel   =   Roact . createElement ( CoolLabel ,   { \n     text   =   \"henlo my guys\"  })  Roact . reify ( myLabel ,   CoreGui ,   \"Hip Greeting\" )   Functional elements can have children too, you just have to explicitly access and use them:  local   function   StuffContainer ( props ) \n     local   children   =   props [ Roact . Children ] \n\n     return   Roact . createElement ( \"Frame\" ,   { \n         Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ) \n     },   children )  end  local   element   =   Roact . createElement ( StuffContainer ,   {},   { \n     A   =   Roact . createElement ( \"TextButton\" ), \n     B   =   Roact . createElement ( \"Frame\" ),  })   When reified,  element  would result in this Roblox hierarchy:  Frame\n    - TextButton (named 'A')\n    - Frame (named 'B')",
            "title": "Functional Components"
        },
        {
            "location": "/guide/elements-components/#stateful-components",
            "text": "Functions are to classes as functional components are to stateful components.  Stateful components are very similar to functional components in that the meat of their code is just a function that returns an element or  nil :  local   CoolLabel   =   Roact . Component : extend ( \"CoolLabel\" )  function   CoolLabel : render () \n     local   text   =   self . props . text \n\n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   text \n     })  end   It's important that the  render  function in a stateful component  only  uses values from  props  and  state  to determine what to render!  The primary difference here is that you call  extend  on  Roact.Component , passing in a name to give to your new component. This name is used for debugging.  Stateful components also have a notion of state, which lets them keep track of their own data that can change. See  the 'counter' example  for a good example of how to utilize state.",
            "title": "Stateful Components"
        },
        {
            "location": "/guide/elements-components/#higher-order-components-hoc",
            "text": "A higher-order component (or HOC) is just a function that returns a component. It's a common pattern for APIs like Roact-Rodux that wrap an existing component with some extra features.",
            "title": "Higher-Order Components (HOC)"
        },
        {
            "location": "/guide/props-and-state/",
            "text": "Props and State\n\u00b6\n\n\nProps\n\u00b6\n\n\nEvery Roact component instance has an associated set of props given to it. You specify these when you're creaing an element:\n\n\nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \nBackgroundColor3\n \n=\n \nColor3\n.\nnew\n(\n1\n,\n \n0\n,\n \n0\n),\n\n    \n-- Your 'props' go here!\n\n\n})\n\n\n\n\n\n\nIn the case of primitive elements, these props (mostly) turn directly into the values attached to the Roblox instance.\n\n\nState\n\u00b6\n\n\nState is attached to \nstateful\n Roact component instances. From inside a stateful component, you can read it with \nself.state\n, and write to it using \nself:setState\n:\n\n\nlocal\n \nMyComponent\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"MyComponent\"\n)\n\n\n\nfunction\n \nMyComponent\n:\ninit\n()\n\n    \n-- The only time you should ever assign to self.state directly is in your constructor.\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \nvalue\n \n=\n \n1\n,\n\n    \n}\n\n\nend\n\n\n\nfunction\n \nMyComponent\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n        \nBackgroundColor3\n \n=\n \nColor3\n.\nnew\n(\nself\n.\nstate\n.\nvalue\n,\n \n0\n,\n \n0\n)\n\n    \n})\n\n\nend",
            "title": "Props and State"
        },
        {
            "location": "/guide/props-and-state/#props-and-state",
            "text": "",
            "title": "Props and State"
        },
        {
            "location": "/guide/props-and-state/#props",
            "text": "Every Roact component instance has an associated set of props given to it. You specify these when you're creaing an element:  Roact . createElement ( \"Frame\" ,   { \n     BackgroundColor3   =   Color3 . new ( 1 ,   0 ,   0 ), \n     -- Your 'props' go here!  })   In the case of primitive elements, these props (mostly) turn directly into the values attached to the Roblox instance.",
            "title": "Props"
        },
        {
            "location": "/guide/props-and-state/#state",
            "text": "State is attached to  stateful  Roact component instances. From inside a stateful component, you can read it with  self.state , and write to it using  self:setState :  local   MyComponent   =   Roact . Component : extend ( \"MyComponent\" )  function   MyComponent : init () \n     -- The only time you should ever assign to self.state directly is in your constructor. \n     self . state   =   { \n         value   =   1 , \n     }  end  function   MyComponent : render () \n     return   Roact . createElement ( \"Frame\" ,   { \n         BackgroundColor3   =   Color3 . new ( self . state . value ,   0 ,   0 ) \n     })  end",
            "title": "State"
        },
        {
            "location": "/guide/lifecycle/",
            "text": "Lifecycle\n\u00b6\n\n\nRoact calls special \nlifecycle\n events on stateful components that can be overridden.\n\n\nThese are:\n\n \ndidMount()\n, called after the component and its children are fully created\n\n \nwillUnmount()\n, called just before the component is destroyed\n\n \nshouldUpdate(nextProps, nextState)\n, called to decide whether to update, or ignore a change\n\n \nwillUpdate(nextProps, nextState)\n, called just before the component is given new props/state\n* \ndidUpdate(prevProps, prevState)\n, called after the component handled an update\n\n\nTo use them, define the appropriate methods on a stateful component:\n\n\nlocal\n \nTestComponent\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"TestComponent\"\n)\n\n\n\n-- We have to override this for every component\n\n\nfunction\n \nTestComponent\n:\nrender\n()\n\n    \nreturn\n \nnil\n\n\nend\n\n\n\nfunction\n \nTestComponent\n:\ndidMount\n()\n\n    \nprint\n(\n\"We were mounted!\"\n)\n\n\nend\n\n\n\nfunction\n \nTestComponent\n:\nwillUnmount\n()\n\n    \nprint\n(\n\"We're about to unmount!\"\n)\n\n\nend\n\n\n\n\n\n\nNote:\n If you are calling \nsetState\n within \ndidMount\n or \ndidUpdate\n, make sure that you are not calling \nsetState\n unconditionally. If \nsetState\n is called every time \ndidMount\n or \ndidUpdate\n is called, you will cause a stack overflow error.",
            "title": "Lifecycle of Components"
        },
        {
            "location": "/guide/lifecycle/#lifecycle",
            "text": "Roact calls special  lifecycle  events on stateful components that can be overridden.  These are:   didMount() , called after the component and its children are fully created   willUnmount() , called just before the component is destroyed   shouldUpdate(nextProps, nextState) , called to decide whether to update, or ignore a change   willUpdate(nextProps, nextState) , called just before the component is given new props/state\n*  didUpdate(prevProps, prevState) , called after the component handled an update  To use them, define the appropriate methods on a stateful component:  local   TestComponent   =   Roact . Component : extend ( \"TestComponent\" )  -- We have to override this for every component  function   TestComponent : render () \n     return   nil  end  function   TestComponent : didMount () \n     print ( \"We were mounted!\" )  end  function   TestComponent : willUnmount () \n     print ( \"We're about to unmount!\" )  end   Note:  If you are calling  setState  within  didMount  or  didUpdate , make sure that you are not calling  setState  unconditionally. If  setState  is called every time  didMount  or  didUpdate  is called, you will cause a stack overflow error.",
            "title": "Lifecycle"
        },
        {
            "location": "/guide/usage-with-rodux/",
            "text": "Usage with Rodux\n\u00b6\n\n\nReact and \nRodux\n get along very well with use of \nRoactRodux\n.\n\n\nTo connect to the store in a component, use \nRoactRodux.connect\n to generate a wrapper component:\n\n\n-- Write a regular component first\n\n\nlocal\n \nfunction\n \nUserCard\n(\nprops\n)\n\n    \nlocal\n \nname\n \n=\n \nprops\n.\nname\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nText\n \n=\n \n(\n\"Hello, %s!\"\n):\nformat\n(\nname\n)\n\n    \n})\n\n\nend\n\n\n\n-- Generate a specialized version of this component that depends on the store\n\n\nlocal\n \nCurrentUserCard\n \n=\n \nRoactRodux\n.\nconnect\n(\nfunction\n(\nstore\n)\n\n    \nlocal\n \nstate\n \n=\n \nstore\n:\ngetState\n()\n\n\n    \n-- The return value of this function is passed as props to UserCard\n\n    \n-- Any props passed to CurrentUserCard will also be passed.\n\n    \nreturn\n \n{\n\n        \nname\n \n=\n \nstate\n.\ncurrentUser\n.\nname\n\n    \n}\n\n\nend\n)(\nUserCard\n)\n\n\n\n\n\n\nThen, wrap the root component of the app (which doesn't need to connect to the Rodux store) by making it a child of a ReactRodux \nStoreProvider\n:\n\n\n-- Our app just displays the current user's name\n\n\nlocal\n \nfunction\n \nApp\n(\nprops\n)\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\nCurrentUserCard\n)\n\n\nend\n\n\n\n-- Create our store like normal\n\n\nlocal\n \nstore\n \n=\n \nRodux\n.\nStore\n.\nnew\n(\nreducer\n)\n\n\n\n-- Instead of creating the App directly, we create a StoreProvider above it\n\n\n-- We have to pass `store` as a prop to tell StoreProvider what store to connect to!\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\nRoactRodux\n.\nStoreProvider\n,\n \n{\n\n    \nstore\n \n=\n \nstore\n\n\n},\n \n{\n\n    \nApp\n \n=\n \nRoact\n.\ncreateElement\n(\nApp\n)\n\n\n})\n\n\n\n\n\n\nFor a complete example, check out the \nRoact with Rodux example\n.",
            "title": "Usage with Rodux"
        },
        {
            "location": "/guide/usage-with-rodux/#usage-with-rodux",
            "text": "React and  Rodux  get along very well with use of  RoactRodux .  To connect to the store in a component, use  RoactRodux.connect  to generate a wrapper component:  -- Write a regular component first  local   function   UserCard ( props ) \n     local   name   =   props . name \n\n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Text   =   ( \"Hello, %s!\" ): format ( name ) \n     })  end  -- Generate a specialized version of this component that depends on the store  local   CurrentUserCard   =   RoactRodux . connect ( function ( store ) \n     local   state   =   store : getState () \n\n     -- The return value of this function is passed as props to UserCard \n     -- Any props passed to CurrentUserCard will also be passed. \n     return   { \n         name   =   state . currentUser . name \n     }  end )( UserCard )   Then, wrap the root component of the app (which doesn't need to connect to the Rodux store) by making it a child of a ReactRodux  StoreProvider :  -- Our app just displays the current user's name  local   function   App ( props ) \n     return   Roact . createElement ( CurrentUserCard )  end  -- Create our store like normal  local   store   =   Rodux . Store . new ( reducer )  -- Instead of creating the App directly, we create a StoreProvider above it  -- We have to pass `store` as a prop to tell StoreProvider what store to connect to!  local   element   =   Roact . createElement ( RoactRodux . StoreProvider ,   { \n     store   =   store  },   { \n     App   =   Roact . createElement ( App )  })   For a complete example, check out the  Roact with Rodux example .",
            "title": "Usage with Rodux"
        },
        {
            "location": "/api-reference/",
            "text": "Roact API Reference\n\u00b6\n\n\nObjects\n\u00b6\n\n\nRoact.Component\n\u00b6\n\n\nThe base component instance that can be extended to make stateful components.\n\n\nCall \nRoact.Component:extend(\"ComponentName\")\n to make a new stateful component with a given name.\n\n\nRoact.PureComponent\n\u00b6\n\n\nAn extension of \nRoact.Component\n that only re-renders if its props or state change.\n\n\nPureComponent\n implements \nshouldUpdate\n with a sane default. It's possible that \nPureComponent\n could be slower than doing a wasteful re-render, so measure!\n\n\nConstants\n\u00b6\n\n\nRoact.Children\n\u00b6\n\n\nThis is the key that Roact uses internally to store the children that are attached to a Roact element.\n\n\nIf you're writing a new functional or stateful element that needs to be used like a primitive component, you can access \nRoact.Children\n in your props table.\n\n\nRoact.Ref\n\u00b6\n\n\nUsed to access underlying Roblox instances. See \nthe refs example\n for more details.\n\n\nRoact.Event\n\u00b6\n\n\nIndex into this object to get handles that can be used for attaching events to Roblox objects. See \nthe events example\n for more details.\n\n\nMethods\n\u00b6\n\n\nRoact.createElement\n\u00b6\n\n\nRoact.createElement(component, [props, [children]]) -> RoactElement\n\n\n\n\n\nCreates a new Roact element representing the given \ncomponent\n.\n\n\nThe \nchildren\n argument is shorthand for adding a \nRoact.Children\n key to \nprops\n. It should be specified as a dictionary of names to elements.\n\n\ncomponent\n can be a string, a function, or a table created by \nComponent:extend\n.\n\n\n\n\nCaution\n\n\nOnce \nprops\n or \nchildren\n are passed into the \ncreateElement\n, make sure not to modify them!\n\n\n\n\nRoact.reify\n\u00b6\n\n\nRoact.reify(element, [parent, [key]]) -> RoactComponentInstance\n\n\n\n\n\nCreates a Roblox Instance given a Roact element, and optionally a \nparent\n to put it in, and a \nkey\n to use as the instance's \nName\n.\n\n\nThe result is a \nRoactComponentInstance\n, which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like \nRoact.teardown\n and the future debug API.\n\n\nRoact.teardown\n\u00b6\n\n\nRoact.teardown(instance)\n\n\n\n\n\nDestroys the given \nRoactComponentInstance\n and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by \nRoact.reify\n.\n\n\nRoact.oneChild\n\u00b6\n\n\nRoact.oneChild(children) -> RoactElement | nil\n\n\nGiven a dictionary of children, returns a single child element.\n\n\nIf \nchildren\n contains more than one child, \noneChild\n function will throw an error. This is intended to denote an error when using the component using \noneChild\n.\n\n\nIf \nchildren\n is \nnil\n or contains no children, \noneChild\n will return \nnil\n.\n\n\nRoact.isPrimitiveElement\n\u00b6\n\n\nRoact.isPrimitveElement(element) -> bool\n\n\n\n\n\nDetermines whether the given \nelement\n is primtive. These elements are created with a string parameter to \ncreateElement\n and represent a Roblox instance.\n\n\nRoact.isFunctionalElement\n\u00b6\n\n\nRoact.isFunctionalElement(element) -> bool\n\n\n\n\n\nDetermines whether the given \nelement\n is functional. These elements are created with a function parameter to \ncreateElement\n and represent a stateless Roact component.\n\n\nRoact.isStatefulElement\n\u00b6\n\n\nRoact.isStatefulElement(element) -> bool\n\n\n\n\n\nDetermines whether the given \nelement\n is stateful. These elements are created with a table parameter to \ncreateElement\n and represent a \npotentially\n stateful Roact component.",
            "title": "API Reference"
        },
        {
            "location": "/api-reference/#roact-api-reference",
            "text": "",
            "title": "Roact API Reference"
        },
        {
            "location": "/api-reference/#objects",
            "text": "",
            "title": "Objects"
        },
        {
            "location": "/api-reference/#roactcomponent",
            "text": "The base component instance that can be extended to make stateful components.  Call  Roact.Component:extend(\"ComponentName\")  to make a new stateful component with a given name.",
            "title": "Roact.Component"
        },
        {
            "location": "/api-reference/#roactpurecomponent",
            "text": "An extension of  Roact.Component  that only re-renders if its props or state change.  PureComponent  implements  shouldUpdate  with a sane default. It's possible that  PureComponent  could be slower than doing a wasteful re-render, so measure!",
            "title": "Roact.PureComponent"
        },
        {
            "location": "/api-reference/#constants",
            "text": "",
            "title": "Constants"
        },
        {
            "location": "/api-reference/#roactchildren",
            "text": "This is the key that Roact uses internally to store the children that are attached to a Roact element.  If you're writing a new functional or stateful element that needs to be used like a primitive component, you can access  Roact.Children  in your props table.",
            "title": "Roact.Children"
        },
        {
            "location": "/api-reference/#roactref",
            "text": "Used to access underlying Roblox instances. See  the refs example  for more details.",
            "title": "Roact.Ref"
        },
        {
            "location": "/api-reference/#roactevent",
            "text": "Index into this object to get handles that can be used for attaching events to Roblox objects. See  the events example  for more details.",
            "title": "Roact.Event"
        },
        {
            "location": "/api-reference/#methods",
            "text": "",
            "title": "Methods"
        },
        {
            "location": "/api-reference/#roactcreateelement",
            "text": "Roact.createElement(component, [props, [children]]) -> RoactElement  Creates a new Roact element representing the given  component .  The  children  argument is shorthand for adding a  Roact.Children  key to  props . It should be specified as a dictionary of names to elements.  component  can be a string, a function, or a table created by  Component:extend .   Caution  Once  props  or  children  are passed into the  createElement , make sure not to modify them!",
            "title": "Roact.createElement"
        },
        {
            "location": "/api-reference/#roactreify",
            "text": "Roact.reify(element, [parent, [key]]) -> RoactComponentInstance  Creates a Roblox Instance given a Roact element, and optionally a  parent  to put it in, and a  key  to use as the instance's  Name .  The result is a  RoactComponentInstance , which is an opaque handle that represents this specific instance of the root component. You can pass this to APIs like  Roact.teardown  and the future debug API.",
            "title": "Roact.reify"
        },
        {
            "location": "/api-reference/#roactteardown",
            "text": "Roact.teardown(instance)  Destroys the given  RoactComponentInstance  and all of its descendents. Does not operate on a Roblox Instance -- this must be given a handle that was returned by  Roact.reify .",
            "title": "Roact.teardown"
        },
        {
            "location": "/api-reference/#roactonechild",
            "text": "Roact.oneChild(children) -> RoactElement | nil  Given a dictionary of children, returns a single child element.  If  children  contains more than one child,  oneChild  function will throw an error. This is intended to denote an error when using the component using  oneChild .  If  children  is  nil  or contains no children,  oneChild  will return  nil .",
            "title": "Roact.oneChild"
        },
        {
            "location": "/api-reference/#roactisprimitiveelement",
            "text": "Roact.isPrimitveElement(element) -> bool  Determines whether the given  element  is primtive. These elements are created with a string parameter to  createElement  and represent a Roblox instance.",
            "title": "Roact.isPrimitiveElement"
        },
        {
            "location": "/api-reference/#roactisfunctionalelement",
            "text": "Roact.isFunctionalElement(element) -> bool  Determines whether the given  element  is functional. These elements are created with a function parameter to  createElement  and represent a stateless Roact component.",
            "title": "Roact.isFunctionalElement"
        },
        {
            "location": "/api-reference/#roactisstatefulelement",
            "text": "Roact.isStatefulElement(element) -> bool  Determines whether the given  element  is stateful. These elements are created with a table parameter to  createElement  and represent a  potentially  stateful Roact component.",
            "title": "Roact.isStatefulElement"
        },
        {
            "location": "/examples/hello-roact/",
            "text": "Hello, Roact!\n\u00b6\n\n\nThis sample creates a full-screen \nTextLabel\n with a greeting:\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Define a functional component\n\n\nlocal\n \nfunction\n \nHelloComponent\n()\n\n    \n--[[\n\n\n        createElement takes three arguments:\n\n\n            * The component that this element represents\n\n\n            * Optional: a list of properties to provide\n\n\n            * Optional: a dictionary of children -- the key is that child's Name\n\n\n    ]]\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{\n\n    \n},\n \n{\n\n        \nMainLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nText\n \n=\n \n\"Hello, world!\"\n,\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n        \n}),\n\n    \n})\n\n\nend\n\n\n\n-- Create our virtual tree\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\nHelloComponent\n)\n\n\n\n--[[\n\n\n    `reify` turns our virtual tree into real instances and puts the top-most one\n\n\n    in PlayerGui\n\n\n\n    reify takes three arguments:\n\n\n        * The element we're trying to reify\n\n\n        * Optionally, the Roblox Instance to put the result into\n\n\n        * Optionally, what to name the root element we create\n\n\n]]\n\n\nRoact\n.\nreify\n(\nelement\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n,\n \n\"HelloWorld\"\n)\n\n\n\n\n\n\nWe can also write this example using a \nstateful\n component.\n\n\nThis example behaves exactly the same as the functional one above:\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- Create a component type, just like the functional component above\n\n\nlocal\n \nHelloComponent\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"HelloComponent\"\n)\n\n\n\n-- 'render' MUST be overridden.\n\n\nfunction\n \nHelloComponent\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{\n\n    \n},\n \n{\n\n        \nMainLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n            \nText\n \n=\n \n\"Hello, world!\"\n,\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n        \n}),\n\n    \n})\n\n\nend\n\n\n\n-- Create our virtual tree\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\nHelloComponent\n)\n\n\n\n-- Turn our virtual tree into real instances and put them in PlayerGui\n\n\nRoact\n.\nreify\n(\nelement\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n,\n \n\"HelloWorld\"\n)",
            "title": "Hello, Roact!"
        },
        {
            "location": "/examples/hello-roact/#hello-roact",
            "text": "This sample creates a full-screen  TextLabel  with a greeting:  local   Players   =   game : GetService ( \"Players\" )  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Define a functional component  local   function   HelloComponent () \n     --[[          createElement takes three arguments:              * The component that this element represents              * Optional: a list of properties to provide              * Optional: a dictionary of children -- the key is that child's Name      ]] \n\n     return   Roact . createElement ( \"ScreenGui\" ,   { \n     },   { \n         MainLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Text   =   \"Hello, world!\" , \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n         }), \n     })  end  -- Create our virtual tree  local   element   =   Roact . createElement ( HelloComponent )  --[[      `reify` turns our virtual tree into real instances and puts the top-most one      in PlayerGui      reify takes three arguments:          * The element we're trying to reify          * Optionally, the Roblox Instance to put the result into          * Optionally, what to name the root element we create  ]]  Roact . reify ( element ,   Players . LocalPlayer . PlayerGui ,   \"HelloWorld\" )   We can also write this example using a  stateful  component.  This example behaves exactly the same as the functional one above:  local   Players   =   game : GetService ( \"Players\" )  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- Create a component type, just like the functional component above  local   HelloComponent   =   Roact . Component : extend ( \"HelloComponent\" )  -- 'render' MUST be overridden.  function   HelloComponent : render () \n     return   Roact . createElement ( \"ScreenGui\" ,   { \n     },   { \n         MainLabel   =   Roact . createElement ( \"TextLabel\" ,   { \n             Text   =   \"Hello, world!\" , \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n         }), \n     })  end  -- Create our virtual tree  local   element   =   Roact . createElement ( HelloComponent )  -- Turn our virtual tree into real instances and put them in PlayerGui  Roact . reify ( element ,   Players . LocalPlayer . PlayerGui ,   \"HelloWorld\" )",
            "title": "Hello, Roact!"
        },
        {
            "location": "/examples/counter/",
            "text": "Stateful Counter\n\u00b6\n\n\nIn \nHello, Roact!\n, two simple ways of creating a static component were shown off.\n\n\nOf course, Roact wouldn't be useful if state didn't change, so we're going to build a component that shows the number of seconds since it was created.\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- A functional component to render the current tick.\n\n\n-- This component has no local state. Most components are like this!\n\n\nlocal\n \nfunction\n \nTickLabel\n(\nprops\n)\n\n    \nlocal\n \nvalue\n \n=\n \nprops\n.\nvalue\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"TextLabel\"\n,\n \n{\n\n        \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n        \nText\n \n=\n \n(\n\"Current tick is %d!\"\n):\nformat\n(\nvalue\n),\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nApp\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"App\"\n)\n\n\n\nfunction\n \nApp\n:\ninit\n()\n\n    \n-- State that cannot affect rendering can exist directly on the instance.\n\n    \n-- This variable is used to kill the timer loop when the component ends.\n\n    \nself\n.\nrunning\n \n=\n \nfalse\n\n\n    \n-- State that changes rendering must exist in `state`!\n\n    \n-- You can only directly assign to `state` in the constructor.\n\n    \nself\n.\nstate\n \n=\n \n{\n\n        \ncount\n \n=\n \n0\n\n    \n}\n\n\nend\n\n\n\nfunction\n \nApp\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{\n\n    \n},\n \n{\n\n        \n-- We can render our own components just like Roblox primitives\n\n        \nCount\n \n=\n \nRoact\n.\ncreateElement\n(\nTickLabel\n,\n \n{\n\n            \nvalue\n \n=\n \nself\n.\nstate\n.\ncount\n,\n\n        \n}),\n\n    \n})\n\n\nend\n\n\n\nfunction\n \nApp\n:\ndidMount\n()\n\n    \n-- Use 'didMount' to be notified when a component instance is created\n\n\n    \nspawn\n(\nfunction\n()\n\n        \nself\n.\nrunning\n \n=\n \ntrue\n\n\n        \nwhile\n \nself\n.\nrunning\n \ndo\n\n            \n-- Use 'setState' to update the component and patch the current\n\n            \n-- state with new properties.\n\n            \n-- Don't set `state` directly!\n\n            \nself\n:\nsetState\n({\n\n                \ncount\n \n=\n \nself\n.\nstate\n.\ncount\n \n+\n \n1\n\n            \n})\n\n\n            \nwait\n(\n1\n)\n\n        \nend\n\n    \nend\n)\n\n\nend\n\n\n\nfunction\n \nApp\n:\nwillUnmount\n()\n\n    \n-- 'willUnmount' notifies you when your component is about to be removed.\n\n    \n-- Do any cleanup here, like terminating a loop!\n\n    \nself\n.\nrunning\n \n=\n \nfalse\n\n\nend\n\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\nApp\n)\n\n\n\nRoact\n.\nreify\n(\nelement\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n,\n \n\"StatefulCounter\"\n)",
            "title": "Stateful Counter"
        },
        {
            "location": "/examples/counter/#stateful-counter",
            "text": "In  Hello, Roact! , two simple ways of creating a static component were shown off.  Of course, Roact wouldn't be useful if state didn't change, so we're going to build a component that shows the number of seconds since it was created.  local   Players   =   game : GetService ( \"Players\" )  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- A functional component to render the current tick.  -- This component has no local state. Most components are like this!  local   function   TickLabel ( props ) \n     local   value   =   props . value \n\n     return   Roact . createElement ( \"TextLabel\" ,   { \n         Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n         Text   =   ( \"Current tick is %d!\" ): format ( value ), \n     })  end  local   App   =   Roact . Component : extend ( \"App\" )  function   App : init () \n     -- State that cannot affect rendering can exist directly on the instance. \n     -- This variable is used to kill the timer loop when the component ends. \n     self . running   =   false \n\n     -- State that changes rendering must exist in `state`! \n     -- You can only directly assign to `state` in the constructor. \n     self . state   =   { \n         count   =   0 \n     }  end  function   App : render () \n     return   Roact . createElement ( \"ScreenGui\" ,   { \n     },   { \n         -- We can render our own components just like Roblox primitives \n         Count   =   Roact . createElement ( TickLabel ,   { \n             value   =   self . state . count , \n         }), \n     })  end  function   App : didMount () \n     -- Use 'didMount' to be notified when a component instance is created \n\n     spawn ( function () \n         self . running   =   true \n\n         while   self . running   do \n             -- Use 'setState' to update the component and patch the current \n             -- state with new properties. \n             -- Don't set `state` directly! \n             self : setState ({ \n                 count   =   self . state . count   +   1 \n             }) \n\n             wait ( 1 ) \n         end \n     end )  end  function   App : willUnmount () \n     -- 'willUnmount' notifies you when your component is about to be removed. \n     -- Do any cleanup here, like terminating a loop! \n     self . running   =   false  end  local   element   =   Roact . createElement ( App )  Roact . reify ( element ,   Players . LocalPlayer . PlayerGui ,   \"StatefulCounter\" )",
            "title": "Stateful Counter"
        },
        {
            "location": "/examples/events/",
            "text": "Events, the Roact Way\n\u00b6\n\n\nRoact lets you declaratively attach and detach from events without worrying about cleanup.\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \nApp\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"App\"\n)\n\n\n\nfunction\n \nApp\n:\nrender\n()\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \n{\n\n    \n},\n \n{\n\n        \nButton\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n0.5\n,\n \n0\n,\n \n0.5\n,\n \n0\n),\n\n            \nPosition\n \n=\n \nUDim2\n.\nnew\n(\n0.5\n,\n \n0\n,\n \n0.5\n,\n \n0\n),\n\n            \nAnchorPoint\n \n=\n \nVector2\n.\nnew\n(\n0.5\n,\n \n0.5\n),\n\n\n            \n-- Attach event listeners using `Roact.Event[eventName]`\n\n            \n-- Event listeners get `rbx` as their first parameter.\n\n            \n-- This is followed by their normal event arguments.\n\n            \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n                \nprint\n(\n\"The button\"\n,\n \nrbx\n,\n \n\"was clicked!\"\n)\n\n            \nend\n\n        \n}),\n\n    \n})\n\n\nend\n\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\nApp\n)\n\n\n\nRoact\n.\nreify\n(\nelement\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n,\n \n\"EventsExample\"\n)",
            "title": "Events, the Roact Way"
        },
        {
            "location": "/examples/events/#events-the-roact-way",
            "text": "Roact lets you declaratively attach and detach from events without worrying about cleanup.  local   Players   =   game : GetService ( \"Players\" )  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   App   =   Roact . Component : extend ( \"App\" )  function   App : render () \n     return   Roact . createElement ( \"ScreenGui\" ,   { \n     },   { \n         Button   =   Roact . createElement ( \"TextButton\" ,   { \n             Size   =   UDim2 . new ( 0.5 ,   0 ,   0.5 ,   0 ), \n             Position   =   UDim2 . new ( 0.5 ,   0 ,   0.5 ,   0 ), \n             AnchorPoint   =   Vector2 . new ( 0.5 ,   0.5 ), \n\n             -- Attach event listeners using `Roact.Event[eventName]` \n             -- Event listeners get `rbx` as their first parameter. \n             -- This is followed by their normal event arguments. \n             [ Roact . Event . MouseButton1Click ]   =   function ( rbx ) \n                 print ( \"The button\" ,   rbx ,   \"was clicked!\" ) \n             end \n         }), \n     })  end  local   element   =   Roact . createElement ( App )  Roact . reify ( element ,   Players . LocalPlayer . PlayerGui ,   \"EventsExample\" )",
            "title": "Events, the Roact Way"
        },
        {
            "location": "/examples/teardown/",
            "text": "Tearing Down Components\n\u00b6\n\n\nRoact components don't need to live forever. It would be pretty awful if they didn't clean up after themselves!\n\n\nThankfully, you can use \nRoact.teardown\n to destroy top-level Roact component instances. In a lot of apps, you don't need to do this, but if you're embedding Roact as part of a larger system, this is helpful.\n\n\nDo not tear down anything except a root node.\n Roact will be very unhappy with you and probably crash if you do.\n\n\nlocal\n \nWorkspace\n \n=\n \ngame\n:\nGetService\n(\n\"Workspace\"\n)\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\n-- We're going to create a very large Part!\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Part\"\n,\n \n{\n\n    \nAnchored\n \n=\n \ntrue\n,\n\n    \nSize\n \n=\n \nVector3\n.\nnew\n(\n50\n,\n \n50\n,\n \n50\n),\n\n\n})\n\n\n\n-- Did you know that 'reify' returns a handle you can use?\n\n\nlocal\n \ninstance\n \n=\n \nRoact\n.\nreify\n(\nelement\n,\n \nWorkspace\n,\n \n\"ObnoxiousPart\"\n)\n\n\n\n-- We can observe that our part was created and stuffed into Workspace:\n\n\nprint\n(\n\"Here it is:\"\n,\n \nWorkspace\n:\nFindFirstChild\n(\n\"ObnoxiousPart\"\n))\n\n\n\n-- And then we can destroy it and observe that it's gone!\n\n\nRoact\n.\nteardown\n(\ninstance\n)\n\n\n\nprint\n(\n\"...and it's gone:\"\n,\n \nWorkspace\n:\nFindFirstChild\n(\n\"ObnoxiousPart\"\n))",
            "title": "Tearing Down Components"
        },
        {
            "location": "/examples/teardown/#tearing-down-components",
            "text": "Roact components don't need to live forever. It would be pretty awful if they didn't clean up after themselves!  Thankfully, you can use  Roact.teardown  to destroy top-level Roact component instances. In a lot of apps, you don't need to do this, but if you're embedding Roact as part of a larger system, this is helpful.  Do not tear down anything except a root node.  Roact will be very unhappy with you and probably crash if you do.  local   Workspace   =   game : GetService ( \"Workspace\" )  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  -- We're going to create a very large Part!  local   element   =   Roact . createElement ( \"Part\" ,   { \n     Anchored   =   true , \n     Size   =   Vector3 . new ( 50 ,   50 ,   50 ),  })  -- Did you know that 'reify' returns a handle you can use?  local   instance   =   Roact . reify ( element ,   Workspace ,   \"ObnoxiousPart\" )  -- We can observe that our part was created and stuffed into Workspace:  print ( \"Here it is:\" ,   Workspace : FindFirstChild ( \"ObnoxiousPart\" ))  -- And then we can destroy it and observe that it's gone!  Roact . teardown ( instance )  print ( \"...and it's gone:\" ,   Workspace : FindFirstChild ( \"ObnoxiousPart\" ))",
            "title": "Tearing Down Components"
        },
        {
            "location": "/examples/refs/",
            "text": "Refs\n\u00b6\n\n\nRefs\n are a concept that let you break out of the Roact paradigm and access Roblox instances directly.\n\n\nPass a function as a prop using the key \nRoact.Ref\n to receive the reference.\n\n\nWhen the object being referenced is destroyed, the given Ref function will be passed nil. Use this opportunity to forget what you were given.\n\n\nIf the Ref object changes, or the instance that the Ref is tied to gets replaced, the old Ref will be passed \nnil\n, and the new Ref will be passed the current object reference.\n\n\nThis feature is intended to be an \nescape hatch\n -- it shouldn't be necessary for the majority of work using Roact. If you do find yourself using a Ref, there may be a Roact paradigm that fits your needs better. Otherwise, you should encapsulate your usage of Ref into a component and expose a cleaner API from it.\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\n\nlocal\n \ncurrentFrame\n\n\n\nlocal\n \nelement\n \n=\n \nRoact\n.\ncreateElement\n(\n\"Frame\"\n,\n \n{\n\n    \n-- Use Roact.Ref as the key to attach a ref, just like events.\n\n    \n[\nRoact\n.\nRef\n]\n \n=\n \nfunction\n(\nrbx\n)\n\n        \n-- All properties are already set and the object has been parented at\n\n        \n-- this point.\n\n        \ncurrentFrame\n \n=\n \nrbx\n\n    \nend\n\n\n})\n\n\n\n-- We'll put our frame into nil, since the parent doesn't matter\n\n\nlocal\n \ninstance\n \n=\n \nRoact\n.\nreify\n(\nelement\n,\n \nnil\n,\n \n\"SomeName\"\n)\n\n\n\nprint\n(\n\"currentFrame is\"\n,\n \ncurrentFrame\n)\n\n\n\n-- Tear down the tree we created\n\n\nRoact\n.\nteardown\n(\ninstance\n)\n\n\n\nprint\n(\n\"currentFrame is now\"\n,\n \ncurrentFrame\n)",
            "title": "Refs"
        },
        {
            "location": "/examples/refs/#refs",
            "text": "Refs  are a concept that let you break out of the Roact paradigm and access Roblox instances directly.  Pass a function as a prop using the key  Roact.Ref  to receive the reference.  When the object being referenced is destroyed, the given Ref function will be passed nil. Use this opportunity to forget what you were given.  If the Ref object changes, or the instance that the Ref is tied to gets replaced, the old Ref will be passed  nil , and the new Ref will be passed the current object reference.  This feature is intended to be an  escape hatch  -- it shouldn't be necessary for the majority of work using Roact. If you do find yourself using a Ref, there may be a Roact paradigm that fits your needs better. Otherwise, you should encapsulate your usage of Ref into a component and expose a cleaner API from it.  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   currentFrame  local   element   =   Roact . createElement ( \"Frame\" ,   { \n     -- Use Roact.Ref as the key to attach a ref, just like events. \n     [ Roact . Ref ]   =   function ( rbx ) \n         -- All properties are already set and the object has been parented at \n         -- this point. \n         currentFrame   =   rbx \n     end  })  -- We'll put our frame into nil, since the parent doesn't matter  local   instance   =   Roact . reify ( element ,   nil ,   \"SomeName\" )  print ( \"currentFrame is\" ,   currentFrame )  -- Tear down the tree we created  Roact . teardown ( instance )  print ( \"currentFrame is now\" ,   currentFrame )",
            "title": "Refs"
        },
        {
            "location": "/examples/roact-rodux/",
            "text": "Roact with Rodux\n\u00b6\n\n\nMore details about the workings of the Roact-Rodux connection can be found in \nUsage with Rodux\n.\n\n\nlocal\n \nPlayers\n \n=\n \ngame\n:\nGetService\n(\n\"Players\"\n)\n\n\nlocal\n \nReplicatedStorage\n \n=\n \ngame\n:\nGetService\n(\n\"ReplicatedStorage\"\n)\n\n\n\nlocal\n \nRoact\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoact\n)\n\n\nlocal\n \nRodux\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRodux\n)\n\n\nlocal\n \nRoactRodux\n \n=\n \nrequire\n(\nReplicatedStorage\n.\nRoactRodux\n)\n\n\n\n-- Roact Portion\n\n\n-- This code doesn't know anything about Rodux.\n\n\n-- It can function as an isolated component -- components designed this way are\n\n\n-- often cleaner!\n\n\nlocal\n \nApp\n \n=\n \nRoact\n.\nComponent\n:\nextend\n(\n\"App\"\n)\n\n\n\nfunction\n \nApp\n:\nrender\n()\n\n    \nlocal\n \ncount\n \n=\n \nself\n.\nprops\n.\ncount\n\n    \nlocal\n \nonClick\n \n=\n \nself\n.\nprops\n.\nonClick\n\n\n    \nreturn\n \nRoact\n.\ncreateElement\n(\n\"ScreenGui\"\n,\n \nnil\n,\n \n{\n\n        \nLabel\n \n=\n \nRoact\n.\ncreateElement\n(\n\"TextButton\"\n,\n \n{\n\n            \nSize\n \n=\n \nUDim2\n.\nnew\n(\n1\n,\n \n0\n,\n \n1\n,\n \n0\n),\n\n            \nText\n \n=\n \n\"Count: \"\n \n..\n \ntostring\n(\ncount\n),\n\n            \nAutoButtonColor\n \n=\n \nfalse\n,\n\n\n            \n[\nRoact\n.\nEvent\n.\nMouseButton1Click\n]\n \n=\n \nonClick\n,\n\n        \n})\n\n    \n})\n\n\nend\n\n\n\n-- React-Rodux Portion\n\n\n-- This code ties together Roact and Rodux by generating a wrapper component.\n\n\n-- The wrapper component maps the 'store' to a set of props we can use.\n\n\n-- It also receives (and passes on) 'props' given from the parent component.\n\n\nlocal\n \nconnectToStore\n \n=\n \nRoactRodux\n.\nconnect\n(\nfunction\n(\nstore\n,\n \nprops\n)\n\n    \nlocal\n \nstate\n \n=\n \nstore\n:\ngetState\n()\n\n\n    \nlocal\n \nfunction\n \nincrement\n()\n\n        \nstore\n:\ndispatch\n(\n\"increment\"\n)\n\n    \nend\n\n\n    \nreturn\n \n{\n\n        \ncount\n \n=\n \nstate\n.\ncount\n,\n\n        \nonClick\n \n=\n \nincrement\n,\n\n    \n}\n\n\nend\n)\n\n\n\n-- In a lot of cases it's useful to preserve the original component\n\n\n-- For this example, we don't need the unwrapped App\n\n\nApp\n \n=\n \nconnectToStore\n(\nApp\n)\n\n\n\n-- Rodux Portion\n\n\n-- This is a reducer that lets you increment a value.\n\n\nlocal\n \nfunction\n \nreducer\n(\nstate\n,\n \naction\n)\n\n    \nstate\n \n=\n \nstate\n \nor\n \n{\n\n        \ncount\n \n=\n \n0\n,\n\n    \n}\n\n\n    \nif\n \naction\n \n==\n \n\"increment\"\n \nthen\n\n        \nreturn\n \n{\n\n            \ncount\n \n=\n \nstate\n.\ncount\n \n+\n \n1\n\n        \n}\n\n    \nend\n\n\n    \nreturn\n \nstate\n\n\nend\n\n\n\nlocal\n \nstore\n \n=\n \nRodux\n.\nStore\n.\nnew\n(\nreducer\n)\n\n\n\n-- We wrap our Roact-Rodux app in a `StoreProvider`, which makes sure our\n\n\n-- components know what store they should be connecting to.\n\n\nlocal\n \napp\n \n=\n \nRoact\n.\ncreateElement\n(\nRoactRodux\n.\nStoreProvider\n,\n \n{\n\n    \nstore\n \n=\n \nstore\n,\n\n\n},\n \n{\n\n    \nApp\n \n=\n \nRoact\n.\ncreateElement\n(\nApp\n),\n\n\n})\n\n\n\nRoact\n.\nreify\n(\napp\n,\n \nPlayers\n.\nLocalPlayer\n.\nPlayerGui\n,\n \n\"Roact-demo-rodux\"\n)",
            "title": "Roact with Rodux"
        },
        {
            "location": "/examples/roact-rodux/#roact-with-rodux",
            "text": "More details about the workings of the Roact-Rodux connection can be found in  Usage with Rodux .  local   Players   =   game : GetService ( \"Players\" )  local   ReplicatedStorage   =   game : GetService ( \"ReplicatedStorage\" )  local   Roact   =   require ( ReplicatedStorage . Roact )  local   Rodux   =   require ( ReplicatedStorage . Rodux )  local   RoactRodux   =   require ( ReplicatedStorage . RoactRodux )  -- Roact Portion  -- This code doesn't know anything about Rodux.  -- It can function as an isolated component -- components designed this way are  -- often cleaner!  local   App   =   Roact . Component : extend ( \"App\" )  function   App : render () \n     local   count   =   self . props . count \n     local   onClick   =   self . props . onClick \n\n     return   Roact . createElement ( \"ScreenGui\" ,   nil ,   { \n         Label   =   Roact . createElement ( \"TextButton\" ,   { \n             Size   =   UDim2 . new ( 1 ,   0 ,   1 ,   0 ), \n             Text   =   \"Count: \"   ..   tostring ( count ), \n             AutoButtonColor   =   false , \n\n             [ Roact . Event . MouseButton1Click ]   =   onClick , \n         }) \n     })  end  -- React-Rodux Portion  -- This code ties together Roact and Rodux by generating a wrapper component.  -- The wrapper component maps the 'store' to a set of props we can use.  -- It also receives (and passes on) 'props' given from the parent component.  local   connectToStore   =   RoactRodux . connect ( function ( store ,   props ) \n     local   state   =   store : getState () \n\n     local   function   increment () \n         store : dispatch ( \"increment\" ) \n     end \n\n     return   { \n         count   =   state . count , \n         onClick   =   increment , \n     }  end )  -- In a lot of cases it's useful to preserve the original component  -- For this example, we don't need the unwrapped App  App   =   connectToStore ( App )  -- Rodux Portion  -- This is a reducer that lets you increment a value.  local   function   reducer ( state ,   action ) \n     state   =   state   or   { \n         count   =   0 , \n     } \n\n     if   action   ==   \"increment\"   then \n         return   { \n             count   =   state . count   +   1 \n         } \n     end \n\n     return   state  end  local   store   =   Rodux . Store . new ( reducer )  -- We wrap our Roact-Rodux app in a `StoreProvider`, which makes sure our  -- components know what store they should be connecting to.  local   app   =   Roact . createElement ( RoactRodux . StoreProvider ,   { \n     store   =   store ,  },   { \n     App   =   Roact . createElement ( App ),  })  Roact . reify ( app ,   Players . LocalPlayer . PlayerGui ,   \"Roact-demo-rodux\" )",
            "title": "Roact with Rodux"
        }
    ]
}